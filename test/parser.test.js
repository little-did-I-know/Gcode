import { describe, it } from 'node:test';
import assert from 'node:assert';
import { GcodeParser } from '../src/parser.js';

describe('GcodeParser', () => {
  it('parses a minimal Cura-style gcode', async () => {
    const parser = new GcodeParser();
    const gcode = [
      ';Generated with Cura_SteamEngine 5.0',
      'G28 ; Home',
      ';LAYER:0',
      'G1 X10 Y10 Z0.2 E1 F1500',
      ';LAYER:1',
      'G1 X20 Y20 Z0.4 E2 F1500',
    ].join('\n');
    await parser.parseAsync(gcode, 'test.gcode');

    assert.strictEqual(parser.layers.length, 2);
    assert.strictEqual(parser.layers[0].number, 0);
    assert.strictEqual(parser.layers[1].number, 1);
  });

  it('detects slicer from header comments', async () => {
    const parser = new GcodeParser();
    const gcode = [
      ';Generated with Cura_SteamEngine 5.0',
      ';LAYER:0',
      'G1 X0 Y0 Z0.2 E1',
    ].join('\n');
    await parser.parseAsync(gcode, 'test.gcode');
    assert.strictEqual(parser.slicerType, 'cura');
  });

  it('detects PrusaSlicer', async () => {
    const parser = new GcodeParser();
    const gcode = [
      '; generated by PrusaSlicer 2.6.0',
      ';LAYER:0',
      'G1 X0 Y0 Z0.2 E1',
    ].join('\n');
    await parser.parseAsync(gcode, 'test.gcode');
    assert.strictEqual(parser.slicerType, 'prusaslicer');
  });

  it('returns unknown for unrecognised slicer', async () => {
    const parser = new GcodeParser();
    const gcode = [
      '; some random comment',
      ';LAYER:0',
      'G1 X0 Y0 Z0.2 E1',
    ].join('\n');
    await parser.parseAsync(gcode, 'test.gcode');
    assert.strictEqual(parser.slicerType, 'unknown');
  });

  it('getLayerByNumber returns correct layer', async () => {
    const parser = new GcodeParser();
    await parser.parseAsync(';LAYER:0\nG1 X1 Y1 Z0.2\n;LAYER:1\nG1 X2 Y2 Z0.4', 'test.gcode');
    const layer = parser.getLayerByNumber(1);
    assert.ok(layer);
    assert.strictEqual(layer.number, 1);
  });

  it('getLayerByNumber returns undefined for missing layer', async () => {
    const parser = new GcodeParser();
    await parser.parseAsync(';LAYER:0\nG1 X1 Y1 Z0.2', 'test.gcode');
    const layer = parser.getLayerByNumber(99);
    assert.strictEqual(layer, undefined);
  });

  it('extracts Z-height from G1 moves', async () => {
    const parser = new GcodeParser();
    const gcode = [
      ';LAYER:0',
      'G1 X10 Y10 Z0.3 E1 F1500',
      ';LAYER:1',
      'G1 X20 Y20 Z0.6 E2 F1500',
    ].join('\n');
    await parser.parseAsync(gcode, 'test.gcode');
    assert.strictEqual(parser.layers[0].zHeight, 0.3);
    assert.strictEqual(parser.layers[1].zHeight, 0.6);
  });

  it('tracks layer moves and bounds', async () => {
    const parser = new GcodeParser();
    const gcode = [
      ';LAYER:0',
      'G1 X10 Y20 Z0.2 E1 F1500',
      'G1 X30 Y40 E2 F1500',
    ].join('\n');
    await parser.parseAsync(gcode, 'test.gcode');
    assert.ok(parser.layerMoves[0].length > 0);
    assert.strictEqual(parser.bounds.maxX, 30);
    assert.strictEqual(parser.bounds.maxY, 40);
  });

  it('parses PrusaSlicer LAYER_CHANGE format', async () => {
    const parser = new GcodeParser();
    const gcode = [
      '; generated by PrusaSlicer 2.6.0',
      ';LAYER_CHANGE',
      ';Z:0.2',
      'G1 X10 Y10 Z0.2 E1',
      ';LAYER_CHANGE',
      ';Z:0.4',
      'G1 X20 Y20 Z0.4 E2',
    ].join('\n');
    await parser.parseAsync(gcode, 'test.gcode');
    assert.strictEqual(parser.layers.length, 2);
    assert.strictEqual(parser.layers[0].zHeight, 0.2);
    assert.strictEqual(parser.layers[1].zHeight, 0.4);
  });

  it('parses section types from ;TYPE: comments', async () => {
    const parser = new GcodeParser();
    const gcode = [
      ';LAYER:0',
      ';TYPE:WALL-OUTER',
      'G1 X10 Y10 Z0.2 E1',
      ';TYPE:FILL',
      'G1 X20 Y20 E2',
    ].join('\n');
    await parser.parseAsync(gcode, 'test.gcode');
    assert.ok(parser.layers[0].sectionTypes.includes('WALL-OUTER'));
    assert.ok(parser.layers[0].sectionTypes.includes('FILL'));
  });

  it('calls progress callback during parseAsync', async () => {
    const parser = new GcodeParser();
    const gcode = ';LAYER:0\nG1 X1 Y1 Z0.2 E1';
    let called = false;
    await parser.parseAsync(gcode, 'test.gcode', (progress) => {
      called = true;
      assert.ok(progress >= 0 && progress <= 1);
    });
    assert.ok(called);
  });

  it('stores fileName from parseAsync', async () => {
    const parser = new GcodeParser();
    await parser.parseAsync(';LAYER:0\nG1 X1 Y1 Z0.2', 'myfile.gcode');
    assert.strictEqual(parser.fileName, 'myfile.gcode');
  });
});
