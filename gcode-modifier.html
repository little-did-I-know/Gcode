<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>G-Code Modifier</title>
<style>
/* ===== RESET & BASE ===== */
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
:root {
  --bg: #111214; --surface: #1c1e22; --surface2: #252830;
  --border: #33363d; --text: #e0e2e8; --text-dim: #8b8f9a;
  --accent: #00c8ff; --accent-dim: rgba(0,200,255,0.12);
  --green: #4ade80; --yellow: #facc15; --red: #f87171; --orange: #fb923c; --purple: #a78bfa;
  --radius: 8px; --mono: 'SF Mono', 'Cascadia Code', 'Fira Code', Consolas, monospace;
}
[data-theme="light"] {
  --bg: #f5f5f7; --surface: #ffffff; --surface2: #f0f0f2;
  --border: #d4d4d8; --text: #1c1e22; --text-dim: #6b7280;
  --accent: #0088cc; --accent-dim: rgba(0,136,204,0.1);
  --green: #16a34a; --yellow: #ca8a04; --red: #dc2626; --orange: #ea580c; --purple: #7c3aed;
}
[data-theme="light"] ::-webkit-scrollbar-thumb { background: #c4c4c8; }
[data-theme="light"] ::-webkit-scrollbar-thumb:hover { background: #a0a0a8; }
html, body { height: 100%; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: var(--bg); color: var(--text); font-size: 14px; }
input, select, textarea, button { font-family: inherit; font-size: inherit; color: inherit; }
button { cursor: pointer; }
::-webkit-scrollbar { width: 6px; height: 6px; }
::-webkit-scrollbar-track { background: transparent; }
::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }
::-webkit-scrollbar-thumb:hover { background: var(--text-dim); }

/* ===== LAYOUT ===== */
#app { display: flex; flex-direction: column; height: 100vh; overflow: hidden; }

/* HEADER */
header { display: flex; align-items: center; gap: 16px; padding: 10px 20px; background: var(--surface); border-bottom: 1px solid var(--border); flex-shrink: 0; min-height: 56px; }
.logo { font-size: 16px; font-weight: 700; white-space: nowrap; }
.logo span { color: var(--accent); }
#dropZone { flex: 1; display: flex; align-items: center; justify-content: center; gap: 8px; padding: 8px 16px; border: 1.5px dashed var(--border); border-radius: var(--radius); color: var(--text-dim); font-size: 13px; transition: all .2s; cursor: pointer; min-height: 36px; }
#dropZone:hover, #dropZone.dragover { border-color: var(--accent); color: var(--accent); background: var(--accent-dim); }
#dropZone svg { flex-shrink: 0; }
#fileInput { display: none; }
#fileInfo { display: none; font-size: 12px; color: var(--text-dim); white-space: nowrap; }
#fileInfo .fname { color: var(--text); font-weight: 600; }
#firmwareSelect { padding: 6px 28px 6px 10px; background: var(--surface2); border: 1px solid var(--border); border-radius: 6px; color: var(--text); font-size: 13px; font-weight: 600; appearance: none; background-image: url("data:image/svg+xml,%3Csvg width='10' height='6' viewBox='0 0 10 6' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1 1l4 4 4-4' stroke='%238b8f9a' stroke-width='1.5' fill='none'/%3E%3C/svg%3E"); background-repeat: no-repeat; background-position: right 8px center; cursor: pointer; }
#firmwareSelect:focus { border-color: var(--accent); outline: none; }
#exportBtn { display: none; padding: 8px 18px; background: var(--accent); color: #000; border: none; border-radius: var(--radius); font-weight: 600; font-size: 13px; transition: opacity .2s; }
#exportBtn:hover { opacity: .85; }

/* MAIN */
main { display: flex; flex: 1; overflow: hidden; }

/* LEFT PANEL — LAYERS */
.panel-left { width: 260px; min-width: 200px; display: flex; flex-direction: column; background: var(--surface); border-right: 1px solid var(--border); }
.panel-header { padding: 12px 14px 8px; font-size: 11px; font-weight: 700; text-transform: uppercase; letter-spacing: .08em; color: var(--text-dim); }
#layerSearch { margin: 0 10px 8px; padding: 7px 10px; background: var(--surface2); border: 1px solid var(--border); border-radius: 6px; color: var(--text); font-size: 13px; outline: none; }
#layerSearch:focus { border-color: var(--accent); }
#layerList { flex: 1; overflow-y: auto; padding: 0 6px 6px; }
.layer-item { display: flex; align-items: center; gap: 8px; padding: 7px 10px; border-radius: 6px; cursor: pointer; font-size: 13px; transition: background .15s; }
.layer-item:hover { background: var(--surface2); }
.layer-item.active { background: var(--accent-dim); color: var(--accent); }
.layer-num { font-weight: 600; min-width: 24px; }
.layer-z { color: var(--text-dim); font-size: 12px; }
.layer-lines { margin-left: auto; color: var(--text-dim); font-size: 11px; }
.layer-mod-badge { width: 8px; height: 8px; border-radius: 50%; background: var(--orange); flex-shrink: 0; }

/* CENTER PANEL — PREVIEW */
.panel-center { flex: 1; display: flex; flex-direction: column; overflow: hidden; }
.preview-toolbar { display: flex; align-items: center; gap: 12px; padding: 8px 16px; border-bottom: 1px solid var(--border); font-size: 12px; color: var(--text-dim); }
.preview-toolbar .jump-input { width: 70px; padding: 4px 8px; background: var(--surface2); border: 1px solid var(--border); border-radius: 4px; color: var(--text); text-align: center; }
#gcodePreview { flex: 1; overflow: auto; padding: 0; font-family: var(--mono); font-size: 13px; line-height: 1.7; }
.code-table { width: 100%; border-collapse: collapse; }
.code-table td { padding: 0 12px; white-space: pre; vertical-align: top; }
.code-table .ln { color: var(--text-dim); text-align: right; user-select: none; width: 50px; min-width: 50px; opacity: .5; padding-right: 8px; border-right: 1px solid var(--border); }
.code-table tr.layer-start td { border-top: 1px solid var(--border); }
.code-table tr.highlight td { background: rgba(250,204,21,.08); }
.code-table tr.mod-line td { background: rgba(251,146,60,.12); }
.code-table tr.mod-line td:last-child { color: var(--orange); font-weight: 600; }
.syn-g { color: #60a5fa; }
.syn-m { color: #4ade80; }
.syn-comment { color: #6b7280; }
.syn-param { color: #c4b5fd; }
.syn-value { color: #fbbf24; }

/* VIEWER */
.viewer-wrap { position: relative; flex: 1; display: none; overflow: hidden; }
.viewer-wrap.active { display: flex; flex-direction: column; }
#gcodePreview.hidden { display: none; }
.viewer-canvas-area { position: relative; flex: 1; overflow: hidden; }
#viewerCanvas { width: 100%; height: 100%; background: var(--bg); cursor: grab; }
#viewerCanvas:active { cursor: grabbing; }
.layer-slider-wrap { display: flex; align-items: center; gap: 10px; padding: 8px 16px; border-top: 1px solid var(--border); background: var(--surface); }
.layer-slider-wrap label { font-size: 12px; color: var(--text-dim); white-space: nowrap; min-width: 80px; }
#layerSlider { flex: 1; accent-color: var(--accent); height: 6px; }
.slider-ticks { position: relative; height: 8px; margin: 0 16px; }
.slider-tick { position: absolute; width: 4px; height: 4px; border-radius: 50%; top: 2px; transform: translateX(-50%); }
.view-toggle { display: flex; gap: 2px; background: var(--surface2); border-radius: 6px; padding: 2px; }
.view-toggle button { padding: 4px 12px; border: none; background: none; color: var(--text-dim); border-radius: 4px; font-size: 12px; font-weight: 600; transition: all .15s; }
.view-toggle button.active { background: var(--accent-dim); color: var(--accent); }
.view-toggle button:hover:not(.active) { color: var(--text); }
.viewer-overlay { position: absolute; top: 12px; left: 12px; right: 12px; pointer-events: none; }
.viewer-info { display: inline-block; padding: 4px 10px; background: rgba(0,0,0,.7); border-radius: 4px; font-size: 12px; color: var(--text); font-family: var(--mono); }
.viewer-mod-banner { margin-top: 8px; padding: 6px 12px; border-radius: 6px; font-size: 12px; font-weight: 600; pointer-events: none; }
.viewer-mod-banner.pause { background: rgba(250,204,21,.2); color: var(--yellow); border: 1px solid rgba(250,204,21,.3); }
.viewer-mod-banner.filament { background: rgba(167,139,250,.2); color: var(--purple); border: 1px solid rgba(167,139,250,.3); }
.viewer-mod-banner.custom { background: rgba(0,200,255,.15); color: var(--accent); border: 1px solid rgba(0,200,255,.25); }
.viewer-mod-banner.recovery { background: rgba(239,68,68,.2); border: 1px solid rgba(239,68,68,.3); color: var(--red, #ef4444); }
.viewer-legend { position: absolute; bottom: 12px; left: 12px; display: flex; flex-wrap: wrap; gap: 10px; pointer-events: none; }
.legend-item { display: flex; align-items: center; gap: 4px; font-size: 10px; color: var(--text-dim); }
.legend-swatch { width: 14px; height: 3px; border-radius: 2px; }

/* EMPTY STATES */
.empty-state { display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; color: var(--text-dim); text-align: center; padding: 40px; gap: 12px; }
.empty-state svg { opacity: .3; }
.empty-state p { max-width: 260px; line-height: 1.5; }

/* PROGRESS BAR */
.parse-progress { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; z-index: 10; }
.parse-progress .bar-wrap { width: 300px; height: 6px; background: var(--surface2); border-radius: 3px; overflow: hidden; margin-top: 8px; }
.parse-progress .bar-fill { height: 100%; background: var(--accent); border-radius: 3px; transition: width 0.1s; }
.parse-progress .bar-label { font-size: 12px; color: var(--text-dim); }

/* RIGHT PANEL — TOOLS */
.panel-right { width: 400px; min-width: 280px; max-width: 60vw; display: flex; flex-direction: column; background: var(--surface); border-left: 1px solid var(--border); position: relative; }
.panel-right-resize { position: absolute; top: 0; left: -4px; width: 8px; height: 100%; cursor: col-resize; z-index: 10; }
.panel-right-resize::after { content: ''; position: absolute; top: 50%; left: 3px; width: 2px; height: 32px; transform: translateY(-50%); border-radius: 1px; background: var(--border); transition: background .2s; }
.panel-right-resize:hover::after, .panel-right-resize.dragging::after { background: var(--accent); }
.tabs { display: flex; border-bottom: 1px solid var(--border); flex-shrink: 0; }
.tab { flex: 1; padding: 10px 6px; text-align: center; font-size: 12px; font-weight: 600; color: var(--text-dim); border: none; background: none; border-bottom: 2px solid transparent; transition: all .2s; }
.tab:hover { color: var(--text); }
.tab.active { color: var(--accent); border-bottom-color: var(--accent); }
.tab-content { display: none; padding: 14px; overflow-y: auto; flex: 1; }
.tab-content.active { display: block; }

/* FORMS */
.form-group { margin-bottom: 14px; }
.form-group label { display: block; font-size: 12px; font-weight: 600; color: var(--text-dim); margin-bottom: 5px; text-transform: uppercase; letter-spacing: .05em; }
.form-row { display: flex; gap: 10px; }
.form-row .form-group { flex: 1; }
.input, .select { width: 100%; padding: 8px 10px; background: var(--surface2); border: 1px solid var(--border); border-radius: 6px; color: var(--text); outline: none; }
.input:focus, .select:focus { border-color: var(--accent); }
.select { appearance: none; background-image: url("data:image/svg+xml,%3Csvg width='10' height='6' viewBox='0 0 10 6' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1 1l4 4 4-4' stroke='%238b8f9a' stroke-width='1.5' fill='none'/%3E%3C/svg%3E"); background-repeat: no-repeat; background-position: right 10px center; padding-right: 28px; }
.checkbox-row { display: flex; align-items: center; gap: 8px; margin-bottom: 10px; font-size: 13px; }
.checkbox-row input[type="checkbox"] { accent-color: var(--accent); width: 16px; height: 16px; }
.btn { display: inline-flex; align-items: center; justify-content: center; gap: 6px; padding: 9px 16px; border-radius: 6px; font-weight: 600; font-size: 13px; border: none; transition: all .2s; width: 100%; }
.btn-primary { background: var(--accent); color: #000; }
.btn-primary:hover { opacity: .85; }
.btn-outline { background: none; border: 1px solid var(--border); color: var(--text); }
.btn-outline:hover { border-color: var(--accent); color: var(--accent); }
.btn-danger { background: rgba(248,113,113,.12); color: var(--red); }
.btn-danger:hover { background: rgba(248,113,113,.2); }
.hint { font-size: 11px; color: var(--text-dim); margin-top: 4px; line-height: 1.4; }

/* MODIFICATIONS LIST */
.mods-section { border-top: 1px solid var(--border); margin-top: auto; flex-shrink: 0; }
.mods-header { display: flex; align-items: center; justify-content: space-between; padding: 10px 14px; font-size: 12px; font-weight: 700; text-transform: uppercase; letter-spacing: .06em; color: var(--text-dim); }
.mods-count { background: var(--accent-dim); color: var(--accent); padding: 2px 8px; border-radius: 10px; font-size: 11px; }
#modsList { max-height: 220px; overflow-y: auto; padding: 0 8px 8px; }
.mod-item { display: flex; align-items: center; gap: 8px; padding: 8px 10px; background: var(--surface2); border-radius: 6px; margin-bottom: 4px; font-size: 12px; cursor: grab; }
.mod-item:active { cursor: grabbing; }
.mod-badge { padding: 2px 8px; border-radius: 4px; font-size: 10px; font-weight: 700; text-transform: uppercase; }
.mod-badge.pause { background: rgba(250,204,21,.15); color: var(--yellow); }
.mod-badge.filament { background: rgba(167,139,250,.15); color: var(--purple); }
.mod-badge.eject { background: rgba(74,222,128,.15); color: var(--green); }
.mod-badge.custom { background: rgba(0,200,255,.12); color: var(--accent); }
.mod-badge.zoffset { background: rgba(251,146,60,.15); color: var(--orange); }
.mod-badge.recovery { background: rgba(239,68,68,.15); color: var(--red, #ef4444); }
.mod-desc { flex: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.mod-actions { display: flex; gap: 2px; }
.mod-action { width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; border: none; background: none; color: var(--text-dim); border-radius: 4px; }
.mod-action:hover { background: var(--border); color: var(--text); }
.mod-action.delete:hover { color: var(--red); }
.no-mods { text-align: center; padding: 16px; color: var(--text-dim); font-size: 12px; }

/* RADIO GROUP */
.radio-group { display: flex; gap: 6px; flex-wrap: wrap; }
.radio-opt { position: relative; }
.radio-opt input { position: absolute; opacity: 0; pointer-events: none; }
.radio-opt label { display: block; padding: 6px 12px; border: 1px solid var(--border); border-radius: 6px; font-size: 12px; cursor: pointer; transition: all .15s; }
.radio-opt input:checked + label { border-color: var(--accent); background: var(--accent-dim); color: var(--accent); }

/* HOLE DETECTION */
.hole-item { display: flex; align-items: center; gap: 8px; padding: 8px 10px; background: var(--surface2); border-radius: 6px; margin-bottom: 4px; font-size: 12px; cursor: pointer; border: 1px solid transparent; transition: all .15s; }
.hole-item:hover { border-color: var(--border); }
.hole-item.selected { border-color: var(--accent); background: var(--accent-dim); }
.hole-item .hole-id { font-weight: 700; color: var(--accent); min-width: 20px; }
.hole-item .hole-info { flex: 1; }
.hole-item .hole-info span { display: block; color: var(--text-dim); font-size: 11px; }
.hole-list-wrap { max-height: 180px; overflow-y: auto; margin-bottom: 14px; }
.insert-summary { padding: 8px 10px; background: var(--surface2); border-radius: 6px; margin-bottom: 10px; font-size: 12px; }
.insert-summary .insert-item { display: flex; align-items: center; gap: 6px; padding: 3px 0; }
.insert-badge { padding: 2px 8px; border-radius: 4px; font-size: 10px; font-weight: 700; text-transform: uppercase; background: rgba(0,200,255,.12); color: var(--accent); }
#viewerCanvas.hole-mode { cursor: crosshair !important; }
#viewerCanvas.hole-mode:active { cursor: crosshair !important; }
.hole-detect-btn { padding: 4px 10px; border: 1px solid var(--border); background: none; border-radius: 4px; font-size: 11px; font-weight: 600; color: var(--text-dim); transition: all .15s; }
.hole-detect-btn:hover { border-color: var(--accent); color: var(--accent); }
.hole-detect-btn.active { border-color: var(--accent); background: var(--accent-dim); color: var(--accent); }
.detect-controls { display: flex; gap: 8px; align-items: center; margin-bottom: 14px; }
.detect-controls .btn { width: auto; flex: 1; }
.filter-row { display: flex; align-items: center; gap: 8px; margin-bottom: 10px; font-size: 12px; }
.filter-row input[type="range"] { flex: 1; accent-color: var(--accent); height: 4px; }
.filter-row .filter-val { min-width: 32px; text-align: right; color: var(--accent); font-weight: 600; font-family: var(--mono); font-size: 11px; }
.section-label { font-size: 11px; font-weight: 700; text-transform: uppercase; letter-spacing: .06em; color: var(--text-dim); margin-bottom: 8px; padding-top: 8px; border-top: 1px solid var(--border); }
.section-label:first-child { border-top: none; padding-top: 0; }
.no-holes { text-align: center; padding: 16px; color: var(--text-dim); font-size: 12px; }
.computed-layer { padding: 8px 10px; background: rgba(74,222,128,.08); border: 1px solid rgba(74,222,128,.2); border-radius: 6px; margin-bottom: 10px; font-size: 12px; color: var(--green); font-weight: 600; }
.warning-msg { padding: 8px 10px; background: rgba(250,204,21,.08); border: 1px solid rgba(250,204,21,.2); border-radius: 6px; margin-bottom: 10px; font-size: 12px; color: var(--yellow); }

/* SHORTCUTS OVERLAY */
.shortcuts-overlay { display: none; position: fixed; inset: 0; background: rgba(0,0,0,.6); z-index: 100; justify-content: center; align-items: center; }
.shortcuts-overlay.active { display: flex; }
.shortcuts-card { background: var(--surface); border: 1px solid var(--border); border-radius: 12px; padding: 24px 32px; max-width: 420px; width: 90%; max-height: 80vh; overflow-y: auto; }
.shortcuts-card h3 { margin-bottom: 16px; font-size: 16px; }
.shortcuts-card table { width: 100%; font-size: 13px; }
.shortcuts-card td { padding: 4px 0; }
.shortcuts-card kbd { background: var(--surface2); border: 1px solid var(--border); border-radius: 4px; padding: 2px 6px; font-family: var(--mono); font-size: 11px; }
.shortcuts-card .close-btn { float: right; background: none; border: none; color: var(--text-dim); font-size: 18px; cursor: pointer; }

/* RESPONSIVE */
@media (max-width: 1100px) {
  .panel-left { width: 200px; min-width: 160px; }
  .panel-right { width: 340px; min-width: 280px; }
}

@media (max-width: 800px) {
  main { flex-direction: column; }
  .panel-left {
    width: 100%; max-height: 0; overflow: hidden; border: none;
    border-bottom: 1px solid var(--border); transition: max-height .3s;
  }
  .panel-left.drawer-open { max-height: 200px; }
  .panel-right {
    width: 100% !important; max-height: 40vh; border: none;
    border-top: 1px solid var(--border); overflow-y: auto;
  }
  .panel-right-resize { display: none; }
  .panel-center { min-height: 300px; }
  .drawer-toggle { display: inline-flex; }
}

.drawer-toggle {
  display: none; align-items: center; justify-content: center;
  width: 32px; height: 32px; background: none; border: 1px solid var(--border);
  border-radius: 6px; color: var(--text-dim); font-size: 16px; cursor: pointer;
}
.drawer-toggle:hover { border-color: var(--accent); color: var(--accent); }

/* TOAST NOTIFICATIONS */
.toast-container { position: fixed; top: 16px; left: 50%; transform: translateX(-50%); z-index: 200; display: flex; flex-direction: column; gap: 8px; pointer-events: none; align-items: center; }
.toast { pointer-events: auto; padding: 12px 20px; border-radius: 10px; font-size: 14px; font-weight: 600; display: flex; align-items: center; gap: 10px; animation: toastSlide .35s ease; min-width: 260px; max-width: 480px; box-shadow: 0 4px 20px rgba(0,0,0,.35); border: none; }
.toast.success { background: #16a34a; color: #fff; }
.toast.warning { background: #eab308; color: #000; }
.toast.error { background: #dc2626; color: #fff; }
.toast .toast-close { margin-left: auto; background: none; border: none; color: inherit; cursor: pointer; opacity: .7; font-size: 18px; }
.toast .toast-close:hover { opacity: 1; }
@keyframes toastSlide { from { transform: translateY(-20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }

/* ONBOARDING HINTS */
.onboard-hint { position: absolute; background: var(--accent); color: #000; padding: 6px 12px; border-radius: 6px; font-size: 12px; font-weight: 600; z-index: 50; white-space: nowrap; cursor: pointer; animation: hintPulse 2s ease-in-out infinite; top: calc(100% + 8px); left: 0; }
.onboard-hint::after { content: ''; position: absolute; border: 6px solid transparent; }
.onboard-hint.below::after { bottom: 100%; left: 20px; border-bottom-color: var(--accent); }
@keyframes hintPulse { 0%, 100% { opacity: 1; } 50% { opacity: .7; } }

/* Reference tab */
.ref-search-wrap { position: sticky; top: 0; z-index: 2; padding-bottom: 8px; background: var(--bg-primary); }
.ref-firmware-badge { font-size: 11px; color: var(--text-secondary); margin-top: 4px; }
.ref-firmware-badge span { background: var(--accent); color: #fff; padding: 1px 8px; border-radius: 8px; font-weight: 600; font-size: 10px; }
.ref-category { margin-bottom: 12px; }
.ref-category-header { display: flex; align-items: center; gap: 6px; cursor: pointer; padding: 6px 0; font-weight: 700; font-size: 13px; color: var(--text-primary); user-select: none; }
.ref-category-header::before { content: '\25BC'; font-size: 9px; transition: transform .2s; }
.ref-category.collapsed .ref-category-header::before { transform: rotate(-90deg); }
.ref-category.collapsed .ref-category-cards { display: none; }
.ref-card { border: 1px solid var(--border); border-radius: 8px; padding: 10px 12px; margin-bottom: 8px; background: var(--bg-secondary); }
.ref-card-head { display: flex; align-items: baseline; gap: 8px; margin-bottom: 4px; }
.ref-card-code { font-family: var(--mono); font-weight: 700; font-size: 15px; color: var(--accent); }
.ref-card-name { font-weight: 600; font-size: 13px; color: var(--text-primary); }
.ref-card-desc { font-size: 12px; color: var(--text-secondary); margin-bottom: 6px; line-height: 1.4; }
.ref-card-params { width: 100%; font-size: 11px; border-collapse: collapse; margin-bottom: 6px; }
.ref-card-params th { text-align: left; font-weight: 600; color: var(--text-secondary); padding: 2px 8px 2px 0; border-bottom: 1px solid var(--border); }
.ref-card-params td { padding: 2px 8px 2px 0; color: var(--text-primary); }
.ref-card-params td:first-child { font-family: var(--mono); font-weight: 700; color: var(--accent); width: 30px; }
.ref-card-example { font-family: var(--mono); font-size: 11px; background: var(--bg-primary); padding: 4px 8px; border-radius: 4px; color: var(--text-secondary); margin-bottom: 6px; overflow-x: auto; white-space: nowrap; }
.ref-card-firmware { font-size: 11px; padding: 4px 8px; border-radius: 4px; margin-bottom: 6px; border-left: 3px solid var(--accent); background: color-mix(in srgb, var(--accent) 10%, var(--bg-secondary)); color: var(--text-primary); }
.ref-card-insert { font-size: 11px; padding: 3px 10px; border-radius: 4px; border: 1px solid var(--accent); background: transparent; color: var(--accent); cursor: pointer; float: right; }
.ref-card-insert:hover { background: var(--accent); color: #fff; }
.ref-no-results { text-align: center; color: var(--text-secondary); padding: 20px 0; font-size: 13px; }
</style>
</head>
<body>
<div id="app">
  <div class="toast-container" id="toastContainer"></div>
  <!-- HEADER -->
  <header>
    <button class="drawer-toggle" onclick="document.getElementById('panelLeft').classList.toggle('drawer-open')" title="Toggle layers">&#9776;</button>
    <div class="logo"><span>G</span>Code Modifier</div>
    <select id="firmwareSelect" onchange="onFirmwareChange(this.value)">
      <option value="bambu">Bambu Lab</option>
      <option value="klipper">Klipper</option>
      <option value="marlin">Marlin</option>
      <option value="rrf">RepRapFirmware</option>
    </select>
    <div id="dropZone" onclick="document.getElementById('fileInput').click()">
      <svg width="18" height="18" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4M17 8l-5-5-5 5M12 3v12"/></svg>
      <span>Drop .gcode or .bgcode file here or click to upload</span>
    </div>
    <input type="file" id="fileInput" accept=".gcode,.gco,.g,.bgcode">
    <div id="fileInfo">
      <span class="fname" id="fileName"></span>&nbsp;&nbsp;
      <span id="fileMeta"></span>
    </div>
    <button id="themeToggle" onclick="toggleTheme()" style="background:none;border:1px solid var(--border);border-radius:6px;padding:4px 10px;color:var(--text-dim);font-size:14px;cursor:pointer" title="Toggle theme">
      <span id="themeIcon">&#9789;</span>
    </button>
    <button style="background:none;border:1px solid var(--border);border-radius:6px;padding:4px 10px;color:var(--text-dim);font-weight:700;font-size:14px;cursor:pointer" onclick="toggleShortcutsOverlay()" title="Keyboard shortcuts">?</button>
    <button id="exportBtn" onclick="exportGcode()">Export G-Code</button>
  </header>

  <!-- MAIN -->
  <main>
    <!-- LEFT: LAYERS -->
    <div class="panel-left" id="panelLeft">
      <div class="panel-header">Layers</div>
      <input type="text" id="layerSearch" placeholder="Search layers..." oninput="filterLayers(this.value)">
      <div id="layerList">
        <div class="empty-state" id="layerEmpty">
          <svg width="32" height="32" fill="none" stroke="currentColor" stroke-width="1.5" viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" rx="2"/><path d="M3 9h18M9 3v18"/></svg>
          <p>Upload a G-code file to see layers</p>
        </div>
      </div>
    </div>

    <!-- CENTER: PREVIEW -->
    <div class="panel-center">
      <div class="parse-progress" id="parseProgress" style="display:none">
        <div class="bar-label" id="parseLabel">Parsing...</div>
        <div class="bar-wrap"><div class="bar-fill" id="parseBar" style="width:0%"></div></div>
      </div>
      <div class="preview-toolbar">
        <div class="view-toggle">
          <button class="active" onclick="setView('code')" id="viewCodeBtn">Code</button>
          <button onclick="setView('visual')" id="viewVisualBtn">Visual</button>
        </div>
        <span>Go to layer:</span>
        <input type="number" class="jump-input" id="jumpLayer" min="0" placeholder="#" onchange="jumpToLayer(+this.value)">
        <button class="hole-detect-btn" id="holeDetectToggle" onclick="toggleHoleMode()" title="Toggle hole detection mode">Hole Detect</button>
        <button class="hole-detect-btn" id="measureToggle" onclick="toggleMeasureMode()" title="Measure distance">Measure</button>
        <span style="margin-left:auto" id="previewInfo"></span>
      </div>
      <div id="gcodePreview">
        <div class="empty-state" id="previewEmpty">
          <svg width="48" height="48" fill="none" stroke="currentColor" stroke-width="1.2" viewBox="0 0 24 24"><path d="M14.5 2H6a2 2 0 00-2 2v16a2 2 0 002 2h12a2 2 0 002-2V7.5L14.5 2z"/><polyline points="14,2 14,8 20,8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10,9 9,9 8,9"/></svg>
          <p>Upload a .gcode file to preview and modify it</p>
        </div>
      </div>
      <div class="viewer-wrap" id="viewerWrap">
        <div class="viewer-canvas-area">
        <canvas id="viewerCanvas"></canvas>
        <div class="viewer-overlay" id="viewerOverlay"></div>
        <div class="viewer-legend" id="viewerLegend">
          <div class="legend-item"><div class="legend-swatch" style="background:#60a5fa"></div>Outer Wall</div>
          <div class="legend-item"><div class="legend-swatch" style="background:#93c5fd"></div>Inner Wall</div>
          <div class="legend-item"><div class="legend-swatch" style="background:#4ade80"></div>Infill</div>
          <div class="legend-item"><div class="legend-swatch" style="background:#facc15"></div>Support</div>
          <div class="legend-item"><div class="legend-swatch" style="background:#fb923c"></div>Overhang</div>
          <div class="legend-item"><div class="legend-swatch" style="background:#555;border-top:1px dashed #555"></div>Travel</div>
        </div>
        </div>
        <div class="layer-slider-wrap">
          <label id="sliderLabel">Layer 0</label>
          <input type="range" id="layerSlider" min="0" max="0" value="0" oninput="onSliderChange(+this.value)">
          <div class="slider-ticks" id="sliderTicks"></div>
        </div>
      </div>
    </div>

    <!-- RIGHT: TOOLS -->
    <div class="panel-right" id="panelRight">
      <div class="panel-right-resize" id="panelRightResize"></div>
      <div class="tabs">
        <button class="tab active" data-tab="pause" onclick="switchTab('pause')">Pause</button>
        <button class="tab" data-tab="filament" onclick="switchTab('filament')">Filament</button>
        <button class="tab" data-tab="eject" onclick="switchTab('eject')">Eject</button>
        <button class="tab" data-tab="zoffset" onclick="switchTab('zoffset')">Z-Offset</button>
        <button class="tab" data-tab="custom" onclick="switchTab('custom')">Custom</button>
        <button class="tab" data-tab="inserts" onclick="switchTab('inserts')">Inserts</button>
        <button class="tab" data-tab="reference" onclick="switchTab('reference')">Reference</button>
        <button class="tab" data-tab="recovery" onclick="switchTab('recovery')">Recovery</button>
      </div>

      <!-- PAUSE TAB -->
      <div class="tab-content active" id="tab-pause">
        <div class="form-group">
          <label>Layer Number</label>
          <input type="number" class="input" id="pauseLayer" min="0" placeholder="e.g. 42">
        </div>
        <div class="form-group">
          <label>Reminder Message (optional)</label>
          <input type="text" class="input" id="pauseMsg" placeholder="e.g. Insert magnet here">
        </div>
        <div class="form-group">
          <label>Pause Command</label>
          <div class="radio-group" id="pauseTypeGroup"></div>
          <div class="hint" id="pauseHint"></div>
        </div>
        <div class="checkbox-row">
          <input type="checkbox" id="pauseMoveHead" checked>
          <label for="pauseMoveHead">Move head away before pause</label>
        </div>
        <button class="btn btn-primary" onclick="addPause()">+ Add Pause</button>
      </div>

      <!-- FILAMENT TAB -->
      <div class="tab-content" id="tab-filament">
        <div class="form-group">
          <label>Layer Number</label>
          <input type="number" class="input" id="filamentLayer" min="0" placeholder="e.g. 10">
        </div>
        <div class="form-row" id="filamentRow">
          <div class="form-group" id="filamentSlotGroup">
            <label>Filament Slot (AMS)</label>
            <select class="select" id="filamentSlot">
              <option value="0">Slot 1 (S0)</option>
              <option value="1">Slot 2 (S1)</option>
              <option value="2">Slot 3 (S2)</option>
              <option value="3">Slot 4 (S3)</option>
            </select>
          </div>
          <div class="form-group">
            <label>Command</label>
            <select class="select" id="filamentCmd"></select>
          </div>
        </div>
        <div class="hint" id="filamentHint" style="margin-bottom:14px"></div>
        <button class="btn btn-primary" onclick="addFilamentChange()">+ Add Filament Change</button>
      </div>

      <!-- EJECT TAB -->
      <div class="tab-content" id="tab-eject">
        <div class="form-row">
          <div class="form-group">
            <label>Bed Y Position (mm)</label>
            <input type="number" class="input" id="ejectY" value="220" min="0" max="300">
          </div>
          <div class="form-group">
            <label>Head Z Clearance (mm)</label>
            <input type="number" class="input" id="ejectZ" value="10" min="0" max="50">
          </div>
        </div>
        <div class="form-group">
          <label>Feed Rate (mm/min)</label>
          <input type="number" class="input" id="ejectFeed" value="6000" min="1000" max="15000" step="500">
        </div>
        <div class="checkbox-row">
          <input type="checkbox" id="ejectHeatersOff" checked>
          <label for="ejectHeatersOff">Turn off heaters after eject</label>
        </div>
        <div class="checkbox-row">
          <input type="checkbox" id="ejectHomeZ">
          <label for="ejectHomeZ">Home Z axis after eject</label>
        </div>
        <div class="checkbox-row">
          <input type="checkbox" id="ejectLoop">
          <label for="ejectLoop">Loop mode (restart print)</label>
        </div>
        <div class="hint" id="ejectHint" style="margin-bottom:14px"></div>
        <button class="btn btn-primary" onclick="addEject()">+ Add Eject Sequence</button>
      </div>

      <!-- Z-OFFSET TAB -->
      <div class="tab-content" id="tab-zoffset">
        <div class="form-group">
          <label>Start Layer</label>
          <input type="number" class="input" id="zoffsetLayer" min="0" placeholder="e.g. 10">
        </div>
        <div class="form-group">
          <label>End Layer (optional)</label>
          <input type="text" class="input" id="zoffsetEndLayer" placeholder="Leave blank for all remaining">
          <div class="hint">If blank, the offset applies from the start layer to the end of the print.</div>
        </div>
        <div class="form-group">
          <label>Z-Offset (mm)</label>
          <input type="number" class="input" id="zoffsetValue" step="0.01" placeholder="e.g. 0.1 or -0.05">
          <div class="hint">Positive = raise nozzle, negative = lower nozzle. Adjusts all Z moves within the specified layer range.</div>
        </div>
        <div class="form-group">
          <label>Note (optional)</label>
          <input type="text" class="input" id="zoffsetNote" placeholder="e.g. Compensate for insert">
        </div>
        <button class="btn btn-primary" onclick="addZOffset()">+ Add Z-Offset</button>
      </div>

      <!-- CUSTOM TAB -->
      <div class="tab-content" id="tab-custom">
        <div class="form-group">
          <label>Layer Number (or "end" for file end)</label>
          <input type="text" class="input" id="customLayer" placeholder="e.g. 50 or end">
        </div>
        <div class="form-group">
          <label>Custom G-Code</label>
          <textarea class="input" id="customGcode" rows="6" style="font-family:var(--mono);font-size:12px;resize:vertical" placeholder="Enter custom G-code lines...&#10;e.g.&#10;G91&#10;G0 Z5&#10;G90"></textarea>
        </div>
        <div class="hint" style="margin-bottom:14px">Insert any custom G-code at a specific layer or at the end of the file. Each line will be inserted as-is.</div>
        <button class="btn btn-primary" onclick="addCustom()">+ Add Custom G-Code</button>
      </div>

      <!-- INSERTS TAB -->
      <div class="tab-content" id="tab-inserts">
        <div class="section-label" style="border-top:none;padding-top:0">Detection</div>
        <div class="detect-controls">
          <button class="btn btn-primary" onclick="detectHolesOnLayer()" style="width:auto;flex:1">Detect (Layer)</button>
          <button class="btn btn-primary" onclick="scanAllHoles()" style="width:auto;flex:1" id="scanAllBtn">Scan All Layers</button>
        </div>
        <div class="filter-row">
          <label>Min diameter</label>
          <input type="range" id="holeMinDia" min="1" max="20" value="4" step="0.5" oninput="document.getElementById('holeMinDiaVal').textContent=this.value+'mm'">
          <span class="filter-val" id="holeMinDiaVal">4mm</span>
        </div>
        <div class="checkbox-row">
          <input type="checkbox" id="holeIgnoreInfill" checked>
          <label for="holeIgnoreInfill">Ignore infill regions</label>
        </div>

        <div class="section-label">Detected Holes</div>
        <div class="hole-list-wrap" id="holeListWrap">
          <div class="no-holes" id="noHoles">Click "Detect Holes" on a layer with the Visual view active</div>
        </div>

        <div class="section-label">Insert Configuration</div>
        <div class="form-row">
          <div class="form-group">
            <label>Insert Height</label>
            <input type="number" class="input" id="insertHeight" min="0.1" step="0.1" value="3" placeholder="mm">
          </div>
          <div class="form-group">
            <label>Unit</label>
            <select class="select" id="insertHeightUnit">
              <option value="mm">mm</option>
              <option value="layers">layers</option>
            </select>
          </div>
        </div>
        <div class="form-row">
          <div class="form-group">
            <label>Insert Diameter</label>
            <input type="number" class="input" id="insertDiameter" min="0.5" step="0.5" value="6" placeholder="mm">
          </div>
          <div class="form-group">
            <label>Label</label>
            <input type="text" class="input" id="insertLabel" placeholder="e.g. Magnet">
          </div>
        </div>
        <div class="form-group">
          <label>Pause Command</label>
          <div class="radio-group" id="insertPauseTypeGroup"></div>
        </div>
        <div class="checkbox-row">
          <input type="checkbox" id="insertMoveHead" checked>
          <label for="insertMoveHead">Move head away before pause</label>
        </div>
        <div id="computedPauseInfo"></div>
        <button class="btn btn-primary" onclick="addInsertsForSelection()">+ Add Pause for Selected Holes</button>
      </div>

      <!-- REFERENCE TAB -->
      <div class="tab-content" id="tab-reference">
        <div class="ref-search-wrap">
          <input type="text" class="input" id="refSearch" placeholder="Search commands (e.g. G1, home, temperature...)" oninput="filterReferenceCards()">
          <div class="ref-firmware-badge" id="refFirmwareBadge"></div>
        </div>
        <div id="refContent"></div>
      </div>

      <!-- RECOVERY TAB -->
      <div class="tab-content" id="tab-recovery">
        <div style="background:rgba(239,68,68,.12);border:1px solid rgba(239,68,68,.3);border-radius:8px;padding:10px 12px;margin-bottom:14px;font-size:12px;color:var(--text);">
          Recovery mode reprints from a specific layer at the bed surface. Print it flat, then glue the two halves together.
        </div>
        <div class="form-row">
          <div class="form-group">
            <label>Resume from Layer</label>
            <input type="number" class="input" id="recoveryLayer" min="1" placeholder="e.g. 50" oninput="syncRecoveryFromLayer()">
          </div>
          <div class="form-group">
            <label>or Height (mm)</label>
            <input type="number" class="input" id="recoveryHeight" min="0" step="0.01" placeholder="e.g. 10.0" oninput="syncRecoveryFromHeight()">
          </div>
        </div>
        <div class="hint" style="margin-bottom:14px">Enter either the layer number or measure the failed print height with calipers. The other field updates automatically.</div>
        <div class="form-group">
          <div class="hint">Z-heights are shifted so the resume layer prints at the original first-layer height. Feedrates on the resume layer are overridden with first-layer speeds for bed adhesion.</div>
        </div>
        <button class="btn btn-primary" onclick="addRecovery()">+ Add Recovery</button>
      </div>

      <!-- MODIFICATIONS LIST -->
      <div class="mods-section">
        <div class="mods-header">
          <span>Modifications</span>
          <span class="mods-count" id="modsCount">0</span>
        </div>
        <div id="modsList">
          <div class="no-mods" id="noMods">No modifications added yet</div>
        </div>
      </div>
    </div>
  </main>
</div>

<div class="shortcuts-overlay" id="shortcutsOverlay" onclick="if(event.target===this)toggleShortcutsOverlay()">
  <div class="shortcuts-card">
    <button class="close-btn" onclick="toggleShortcutsOverlay()">&times;</button>
    <h3>Keyboard Shortcuts</h3>
    <table>
      <tr><td><kbd>Ctrl</kbd>+<kbd>O</kbd></td><td>Open file</td></tr>
      <tr><td><kbd>Ctrl</kbd>+<kbd>E</kbd></td><td>Export</td></tr>
      <tr><td><kbd>Ctrl</kbd>+<kbd>Z</kbd></td><td>Undo</td></tr>
      <tr><td><kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>Z</kbd></td><td>Redo</td></tr>
      <tr><td><kbd>Space</kbd></td><td>Toggle Code/Visual</td></tr>
      <tr><td><kbd>[</kbd> / <kbd>]</kbd></td><td>Previous/Next layer</td></tr>
      <tr><td><kbd>1</kbd>–<kbd>8</kbd></td><td>Switch tool tab</td></tr>
      <tr><td><kbd>F</kbd></td><td>Reset camera</td></tr>
      <tr><td><kbd>?</kbd></td><td>This help</td></tr>
    </table>
  </div>
</div>

<script>
// ===== G-CODE PARSER =====
class GcodeParser {
  constructor() {
    this.lines = [];
    this.layers = [];
    this.headerEnd = 0;
    this.fileName = '';
    this.warnings = [];
    this.skippedLines = 0;
  }

  _detectSlicer(lines) {
    const scanLines = Math.min(50, lines.length);
    for (let i = 0; i < scanLines; i++) {
      const line = lines[i];
      if (line.includes('Generated with Cura_SteamEngine')) return 'cura';
      if (line.includes('generated by PrusaSlicer')) return 'prusaslicer';
      if (line.includes('generated by SuperSlicer')) return 'superslicer';
      if (line.includes('generated by OrcaSlicer')) return 'orcaslicer';
      if (line.includes('G-Code generated by Simplify3D')) return 'simplify3d';
      if (line.includes('Sliced by ideaMaker')) return 'ideamaker';
      if (line.includes('BambuStudio') || line.includes('Bambu Studio')) return 'bambu';
    }
    return 'unknown';
  }

  async parseAsync(text, fileName, onProgress) {
    this.fileName = fileName;
    this.lines = text.split(/\r?\n/);
    this.slicerType = this._detectSlicer(this.lines);
    this.layers = [];
    this.layerMoves = {};
    this.bounds = { minX: Infinity, maxX: -Infinity, minY: Infinity, maxY: -Infinity };
    this.headerEnd = 0;
    this.warnings = [];
    this.skippedLines = 0;

    let currentLayer = null;
    let foundFirstLayer = false;
    // State machine for tracking head position
    let curX = 0, curY = 0, curZ = 0, curE = 0;
    let relativeE = false; // M83 = relative, M82 = absolute
    let currentType = 'DEFAULT';
    // Bambu Studio uses "; CHANGE_LAYER" as a marker, with layer number on a nearby line
    let pendingChangeLayer = false;
    let pendingZHeight = null;

    const CHUNK = 50000;
    const total = this.lines.length;

    for (let start = 0; start < total; start += CHUNK) {
      const end = Math.min(start + CHUNK, total);

    for (let i = start; i < end; i++) {
      const line = this.lines[i].trim();

      // Detect header end
      if (!foundFirstLayer && !this.headerEnd) {
        const lm = line.match(/^;LAYER:(\d+)/i) || line.match(/^; CHANGE_LAYER/) || line.match(/^; layer \d+, Z = /i) || line === ';LAYER_CHANGE';
        if (lm) { this.headerEnd = i; foundFirstLayer = true; }
        else if (line && !line.startsWith(';') && (line.startsWith('G') || line.startsWith('M') || line.startsWith('T'))) {
          if (!this.headerEnd) this.headerEnd = i;
        }
      }

      // Parse layer markers — standard format: ;LAYER:N
      const layerMatch = line.match(/^;LAYER:(\d+)/i);
      if (layerMatch) {
        foundFirstLayer = true;
        if (currentLayer) {
          currentLayer.endLine = i - 1;
          currentLayer.lineCount = currentLayer.endLine - currentLayer.startLine + 1;
        }
        currentLayer = {
          number: parseInt(layerMatch[1]),
          startLine: i, endLine: null, zHeight: null,
          sectionTypes: [], lineCount: 0
        };
        this.layers.push(currentLayer);
        this.layerMoves[currentLayer.number] = [];
        currentType = 'DEFAULT';
      }

      // Parse layer markers — Bambu Studio format: ; CHANGE_LAYER + ; Z_HEIGHT + ; layer num/total_layer_count
      if (line === '; CHANGE_LAYER') {
        pendingChangeLayer = true;
        pendingZHeight = null;
        // Mark the start line as this CHANGE_LAYER comment
        foundFirstLayer = true;
        if (currentLayer) {
          currentLayer.endLine = i - 1;
          currentLayer.lineCount = currentLayer.endLine - currentLayer.startLine + 1;
        }
        // Create a temporary layer — number will be updated when we find the layer num comment
        currentLayer = {
          number: this.layers.length, // temporary, updated below
          startLine: i, endLine: null, zHeight: null,
          sectionTypes: [], lineCount: 0,
          _pending: true
        };
        currentType = 'DEFAULT';
      }

      // Bambu: ; Z_HEIGHT: 0.2
      if (pendingChangeLayer) {
        const zHMatch = line.match(/^; Z_HEIGHT:\s*([\d.]+)/);
        if (zHMatch) {
          pendingZHeight = parseFloat(zHMatch[1]);
          if (currentLayer) currentLayer.zHeight = pendingZHeight;
        }

        // Bambu: ; layer num/total_layer_count: 1/525
        const bambuLayerMatch = line.match(/^; layer num\/total_layer_count:\s*(\d+)\/(\d+)/);
        if (bambuLayerMatch) {
          const layerNum = parseInt(bambuLayerMatch[1]) - 1; // Bambu uses 1-based, convert to 0-based
          if (currentLayer && currentLayer._pending) {
            currentLayer.number = layerNum;
            delete currentLayer._pending;
            this.layers.push(currentLayer);
            this.layerMoves[currentLayer.number] = [];
          }
          pendingChangeLayer = false;
        }
      }

      // Simplify3D: "; layer N, Z = X.XX"
      const s3dLayerMatch = line.match(/^; layer (\d+), Z = ([\d.]+)/i);
      if (s3dLayerMatch) {
        foundFirstLayer = true;
        if (currentLayer) {
          currentLayer.endLine = i - 1;
          currentLayer.lineCount = currentLayer.endLine - currentLayer.startLine + 1;
        }
        currentLayer = {
          number: parseInt(s3dLayerMatch[1]),
          startLine: i, endLine: null,
          zHeight: parseFloat(s3dLayerMatch[2]),
          sectionTypes: [], lineCount: 0
        };
        this.layers.push(currentLayer);
        this.layerMoves[currentLayer.number] = [];
        currentType = 'DEFAULT';
      }

      // PrusaSlicer alternative: ;LAYER_CHANGE + ;Z:X.XX
      if (line === ';LAYER_CHANGE') {
        foundFirstLayer = true;
        if (currentLayer) {
          currentLayer.endLine = i - 1;
          currentLayer.lineCount = currentLayer.endLine - currentLayer.startLine + 1;
        }
        currentLayer = {
          number: this.layers.length,
          startLine: i, endLine: null, zHeight: null,
          sectionTypes: [], lineCount: 0
        };
        this.layers.push(currentLayer);
        this.layerMoves[currentLayer.number] = [];
        currentType = 'DEFAULT';
      }
      if (currentLayer && !currentLayer.zHeight) {
        const zDirectMatch = line.match(/^;Z:([\d.]+)/);
        if (zDirectMatch) currentLayer.zHeight = parseFloat(zDirectMatch[1]);
      }

      // Extract Z-height (fallback from G0/G1 moves)
      if (currentLayer && !currentLayer.zHeight) {
        const zMatch = line.match(/G[01]\s.*Z([\d.]+)/i);
        if (zMatch) currentLayer.zHeight = parseFloat(zMatch[1]);
      }

      // Extract section types — standard: ;TYPE:X  or Bambu: ; FEATURE: X
      if (currentLayer) {
        const typeMatch = line.match(/^;TYPE:(.+)/i) || line.match(/^; FEATURE:\s*(.+)/i);
        if (typeMatch) {
          // Normalize PrusaSlicer/SuperSlicer type names
          const typeNormalize = {
            'External perimeter': 'WALL-OUTER',
            'Perimeter': 'WALL-INNER',
            'Solid infill': 'SOLID',
            'Top solid infill': 'TOP',
            'Bottom solid infill': 'BOTTOM',
            'Bridge infill': 'BRIDGE',
            'Gap fill': 'GAP INFILL',
            'Overhang perimeter': 'OVERHANG',
            'Internal infill': 'FILL',
            'Sparse infill': 'FILL',
            'Skirt': 'SKIRT',
            'Skirt/Brim': 'SKIRT',
            'Support material': 'SUPPORT',
            'Support material interface': 'SUPPORT-INTERFACE',
          };
          const rawType = typeMatch[1].trim();
          currentType = typeNormalize[rawType] || rawType.toUpperCase();
          if (!currentLayer.sectionTypes.includes(currentType)) currentLayer.sectionTypes.push(currentType);
        }

        // Simplify3D: "; outer perimeter", "; inner perimeter", etc.
        if (!typeMatch) {
          const s3dType = line.match(/^; (outer perimeter|inner perimeter|solid layer|infill|support|raft|skirt|gap fill|bridge)/i);
          if (s3dType) {
            const typeMap = {
              'outer perimeter': 'WALL-OUTER',
              'inner perimeter': 'WALL-INNER',
              'solid layer': 'SOLID',
              'infill': 'FILL',
              'support': 'SUPPORT',
              'raft': 'SUPPORT',
              'skirt': 'SKIRT',
              'gap fill': 'GAP INFILL',
              'bridge': 'BRIDGE',
            };
            currentType = typeMap[s3dType[1].toLowerCase()] || s3dType[1].toUpperCase();
            if (!currentLayer.sectionTypes.includes(currentType)) currentLayer.sectionTypes.push(currentType);
          }
        }
      }

      // Track extrusion mode
      if (line === 'M83') relativeE = true;
      if (line === 'M82') relativeE = false;
      if (line.startsWith('G92') && line.includes('E')) { curE = 0; } // Reset E position

      // Parse G0/G1 linear moves for the viewer
      if (currentLayer && this.layerMoves[currentLayer.number] && /^G[01]\s/.test(line)) {
        try {
        const params = {};
        const matches = line.matchAll(/([XYZEF])([-\d.]+)/gi);
        for (const m of matches) params[m[1].toUpperCase()] = parseFloat(m[2]);

        const newX = params.X !== undefined ? params.X : curX;
        const newY = params.Y !== undefined ? params.Y : curY;
        const newZ = params.Z !== undefined ? params.Z : curZ;
        const isG0 = line.startsWith('G0');
        let isExtrude = false;
        if (params.E !== undefined) {
          isExtrude = relativeE ? params.E > 0 : params.E > curE;
          curE = relativeE ? curE + params.E : params.E;
        }

        // Only record XY moves (skip pure Z moves)
        if (newX !== curX || newY !== curY) {
          this.layerMoves[currentLayer.number].push({
            x1: curX, y1: curY, x2: newX, y2: newY,
            type: currentType, extrude: isExtrude && !isG0
          });
          this.bounds.minX = Math.min(this.bounds.minX, curX, newX);
          this.bounds.maxX = Math.max(this.bounds.maxX, curX, newX);
          this.bounds.minY = Math.min(this.bounds.minY, curY, newY);
          this.bounds.maxY = Math.max(this.bounds.maxY, curY, newY);
        }

        curX = newX; curY = newY; curZ = newZ;
        } catch (err) {
          this.skippedLines++;
        }
      }

      // Parse G2/G3 arc moves (Bambu Studio uses arc fitting)
      if (currentLayer && this.layerMoves[currentLayer.number] && /^G[23]\s/.test(line)) {
        try {
        const params = {};
        const matches = line.matchAll(/([XYZEFIJ])([-\d.]+)/gi);
        for (const m of matches) params[m[1].toUpperCase()] = parseFloat(m[2]);

        const newX = params.X !== undefined ? params.X : curX;
        const newY = params.Y !== undefined ? params.Y : curY;
        let isExtrude = false;
        if (params.E !== undefined) {
          isExtrude = relativeE ? params.E > 0 : params.E > curE;
          curE = relativeE ? curE + params.E : params.E;
        }
        const isG2 = line.startsWith('G2'); // clockwise

        // Approximate arc with line segments
        const cx = curX + (params.I || 0);
        const cy = curY + (params.J || 0);
        const r = Math.hypot(params.I || 0, params.J || 0);
        if (r > 0.01) {
          let startAngle = Math.atan2(curY - cy, curX - cx);
          let endAngle = Math.atan2(newY - cy, newX - cx);
          // Adjust sweep direction
          if (isG2) { // CW
            if (endAngle >= startAngle) endAngle -= 2 * Math.PI;
          } else { // CCW
            if (endAngle <= startAngle) endAngle += 2 * Math.PI;
          }
          const segments = Math.max(4, Math.ceil(Math.abs(endAngle - startAngle) / (Math.PI / 12)));
          let prevAX = curX, prevAY = curY;
          for (let s = 1; s <= segments; s++) {
            const t = s / segments;
            const angle = startAngle + (endAngle - startAngle) * t;
            const ax = s === segments ? newX : cx + r * Math.cos(angle);
            const ay = s === segments ? newY : cy + r * Math.sin(angle);
            this.layerMoves[currentLayer.number].push({
              x1: prevAX, y1: prevAY, x2: ax, y2: ay,
              type: currentType, extrude: isExtrude
            });
            this.bounds.minX = Math.min(this.bounds.minX, ax);
            this.bounds.maxX = Math.max(this.bounds.maxX, ax);
            this.bounds.minY = Math.min(this.bounds.minY, ay);
            this.bounds.maxY = Math.max(this.bounds.maxY, ay);
            prevAX = ax; prevAY = ay;
          }
        }

        curX = newX; curY = newY;
        } catch (err) {
          this.skippedLines++;
        }
      }
    }

      if (onProgress) onProgress(Math.min(end / total, 1));
      if (end < total) await new Promise(r => setTimeout(r, 0));
    }

    // Finalize any pending Bambu layer that never got its layer num line
    if (currentLayer && currentLayer._pending) {
      delete currentLayer._pending;
      this.layers.push(currentLayer);
      this.layerMoves[currentLayer.number] = [];
    }

    // Close last layer
    if (currentLayer) {
      currentLayer.endLine = this.lines.length - 1;
      currentLayer.lineCount = currentLayer.endLine - currentLayer.startLine + 1;
    }

    // Sanitize bounds
    if (!isFinite(this.bounds.minX)) this.bounds = { minX: 0, maxX: 256, minY: 0, maxY: 256 };

    return this.layers;
  }

  getLayerByNumber(num) {
    return this.layers.find(l => l.number === num);
  }
}

// ===== G-CODE MODIFIER =====
class GcodeModifier {
  constructor() {
    this.modifications = [];
    this._idCounter = 0;
  }

  _id() { return 'mod_' + (++this._idCounter) + '_' + Date.now(); }

  addPause(layer, message, pauseType, moveHead) {
    const mod = {
      id: this._id(), type: 'pause', layer,
      message: message || '', pauseType, moveHead
    };
    this.modifications.push(mod);
    return mod;
  }

  addFilament(layer, slot, command) {
    const mod = {
      id: this._id(), type: 'filament', layer,
      slot: parseInt(slot), command
    };
    this.modifications.push(mod);
    return mod;
  }

  addEject(config) {
    // Remove existing eject mods (only one eject sequence allowed)
    this.modifications = this.modifications.filter(m => m.type !== 'eject');
    const mod = {
      id: this._id(), type: 'eject', layer: Infinity,
      ...config
    };
    this.modifications.push(mod);
    return mod;
  }

  addRecovery(resumeLayer) {
    // Only one recovery mod allowed — replace existing
    this.modifications = this.modifications.filter(m => m.type !== 'recovery');
    const mod = {
      id: this._id(), type: 'recovery', layer: resumeLayer,
      resumeLayer
    };
    this.modifications.push(mod);
    return mod;
  }

  addZOffset(layer, endLayer, offset, note) {
    const mod = {
      id: this._id(), type: 'zoffset', layer,
      endLayer, offset, note: note || ''
    };
    this.modifications.push(mod);
    return mod;
  }

  addCustom(layer, gcode) {
    const mod = {
      id: this._id(), type: 'custom', layer,
      gcode
    };
    this.modifications.push(mod);
    return mod;
  }

  remove(modId) {
    this.modifications = this.modifications.filter(m => m.id !== modId);
  }

  moveUp(modId) {
    const idx = this.modifications.findIndex(m => m.id === modId);
    if (idx > 0) [this.modifications[idx - 1], this.modifications[idx]] = [this.modifications[idx], this.modifications[idx - 1]];
  }

  moveDown(modId) {
    const idx = this.modifications.findIndex(m => m.id === modId);
    if (idx < this.modifications.length - 1) [this.modifications[idx], this.modifications[idx + 1]] = [this.modifications[idx + 1], this.modifications[idx]];
  }

  getSnippet(mod) {
    const lines = [];
    switch (mod.type) {
      case 'pause': {
        lines.push(`; === PAUSE${mod.message ? ': ' + mod.message : ''} ===`);
        if (mod.moveHead) {
          lines.push('G91 ; Relative positioning');
          lines.push('G1 Z5 F600 ; Lift Z');
          lines.push('G90 ; Absolute positioning');
          lines.push('G1 X5 Y5 F6000 ; Move head to front-left');
        }
        const profile = FIRMWARE[currentFirmware];
        const pauseGcode = profile?.pauseGcode?.[mod.pauseType];
        if (pauseGcode) lines.push(pauseGcode);
        else lines.push(`${mod.pauseType} ; Pause`);
        lines.push('; === END PAUSE ===');
        break;
      }
      case 'filament': {
        lines.push(`; === FILAMENT CHANGE${mod.command === 'M1020' ? ': Slot ' + (mod.slot + 1) : ''} ===`);
        if (mod.command === 'M1020') lines.push(`M1020 S${mod.slot} ; Bambu AMS filament change`);
        else lines.push(`${mod.command} ; Filament change`);
        lines.push('; === END FILAMENT CHANGE ===');
        break;
      }
      case 'eject': {
        lines.push('; === AUTO-EJECT SEQUENCE ===');
        lines.push(`G1 X5 Y${mod.bedY} Z${mod.headZ} F${mod.feedRate} ; Move to eject position`);
        if (mod.heatersOff) {
          lines.push('M104 S0 ; Extruder off');
          lines.push('M140 S0 ; Bed off');
        }
        if (mod.homeZ) lines.push('G28 Z ; Home Z');
        lines.push('M106 S0 ; Fan off');
        if (mod.loop) {
          lines.push('; === LOOP MODE ===');
          lines.push('; Note: True automatic loop requires firmware support or external automation.');
          lines.push('; The printer will stop here. Restart manually or via automation.');
        }
        lines.push('; === END AUTO-EJECT ===');
        break;
      }
      case 'zoffset': {
        const sign = mod.offset >= 0 ? '+' : '';
        const range = mod.endLayer != null ? `layers ${mod.layer}–${mod.endLayer}` : `layer ${mod.layer} onward`;
        lines.push(`; === Z-OFFSET: ${sign}${mod.offset}mm for ${range}${mod.note ? ' (' + mod.note + ')' : ''} ===`);
        break;
      }
      case 'custom': {
        lines.push('; === CUSTOM G-CODE ===');
        mod.gcode.split('\n').forEach(l => lines.push(l));
        lines.push('; === END CUSTOM ===');
        break;
      }
      case 'recovery': {
        lines.push(`; === PRINT RECOVERY: Resume from layer ${mod.resumeLayer} ===`);
        lines.push(`; Layers below ${mod.resumeLayer} removed, Z shifted to bed`);
        lines.push('; === END RECOVERY HEADER ===');
        break;
      }
    }
    return lines;
  }

  applyAll(originalLines, parser) {
    let result = [...originalLines];

    // === RECOVERY: strip layers below resume point, shift Z to bed, override first-layer speeds ===
    const recoveryMod = this.modifications.find(m => m.type === 'recovery');
    let recoveryLineShift = 0; // line offset for other mods after recovery reassembly
    if (recoveryMod && parser.layers.length > 0) {
      const resumeLayer = parser.getLayerByNumber(recoveryMod.resumeLayer);
      const layer0 = parser.layers[0];
      if (resumeLayer && layer0 && resumeLayer.zHeight != null) {
        const layer0Z = layer0.zHeight || 0.2;
        const zShift = resumeLayer.zHeight - layer0Z;

        // 1. Keep preamble (headers + startup gcode) + strip layers before resume point
        const preamble = result.slice(0, layer0.startLine);
        const remaining = result.slice(resumeLayer.startLine);

        // 2. Collect layer-0 extrusion feedrate for speed override
        let layer0Speed = null;
        for (let i = layer0.startLine; i <= layer0.endLine; i++) {
          const line = result[i];
          if (/^G[01]\s/i.test(line.trim()) && /E[\d.]/i.test(line) && /F[\d.]/i.test(line)) {
            const fm = line.match(/F([\d.]+)/i);
            if (fm) { layer0Speed = parseFloat(fm[1]); break; }
          }
        }

        // 3. Reassemble: preamble + recovery header + remaining layers
        const snippet = this.getSnippet(recoveryMod);
        result = [...preamble, ...snippet, ...remaining];

        // 4. Compute line shift so other mods can find correct insertion points
        recoveryLineShift = preamble.length + snippet.length - resumeLayer.startLine;

        // 5. Shift all Z values and renumber layer metadata in remaining lines
        const remainingStart = preamble.length + snippet.length;
        const layerNumOffset = recoveryMod.resumeLayer; // original 0-based layer number of resume layer
        const totalRemaining = parser.layers.length - layerNumOffset;
        for (let i = remainingStart; i < result.length; i++) {
          const trimmed = result[i].trim();
          // Shift G-code Z coordinates
          if (/^G[0123]\s/i.test(trimmed) && /Z[-\d.]/i.test(trimmed)) {
            result[i] = result[i].replace(
              /([Zz])([-\d.]+)/g,
              (match, letter, val) => {
                const newZ = parseFloat(val) - zShift;
                return letter + newZ.toFixed(3);
              }
            );
          }
          // Shift ; Z_HEIGHT: comments
          if (/^; Z_HEIGHT:\s*[\d.]+/.test(trimmed)) {
            result[i] = result[i].replace(
              /(; Z_HEIGHT:\s*)([\d.]+)/,
              (match, prefix, val) => prefix + (parseFloat(val) - zShift).toFixed(2)
            );
          }
          // Renumber ; layer num/total_layer_count: N/M
          const layerNumMatch = trimmed.match(/^; layer num\/total_layer_count:\s*(\d+)\/(\d+)/);
          if (layerNumMatch) {
            const origNum = parseInt(layerNumMatch[1]); // 1-based
            const newNum = origNum - layerNumOffset;
            result[i] = result[i].replace(
              /(; layer num\/total_layer_count:\s*)\d+\/\d+/,
              '$1' + newNum + '/' + totalRemaining
            );
          }
          // Renumber M73 L (layer progress)
          if (/^M73 L\d+/i.test(trimmed)) {
            result[i] = result[i].replace(
              /(M73 L)(\d+)/i,
              (match, prefix, val) => prefix + (parseInt(val) - layerNumOffset)
            );
          }
          // Renumber M991 S0 P (layer notification)
          if (/^M991 S0 P\d+/i.test(trimmed)) {
            result[i] = result[i].replace(
              /(M991 S0 P)(\d+)/i,
              (match, prefix, val) => prefix + (parseInt(val) - layerNumOffset)
            );
          }
          // Shift ;Z: comments (PrusaSlicer)
          if (/^;Z:[\d.]+/.test(trimmed)) {
            result[i] = result[i].replace(
              /(;Z:)([\d.]+)/,
              (match, prefix, val) => prefix + (parseFloat(val) - zShift).toFixed(2)
            );
          }
          // Renumber ;LAYER:N comments (Cura/standard)
          if (/^;LAYER:\d+/i.test(trimmed)) {
            result[i] = result[i].replace(
              /(;LAYER:)(\d+)/i,
              (match, prefix, val) => prefix + (parseInt(val) - layerNumOffset)
            );
          }
        }

        // 6. Override feedrates on resume layer with layer-0 speed
        if (layer0Speed) {
          const resumeEnd = remainingStart + (resumeLayer.endLine - resumeLayer.startLine);
          for (let i = remainingStart; i <= resumeEnd && i < result.length; i++) {
            const trimmed = result[i].trim();
            if (/^G[01]\s/i.test(trimmed) && /E[\d.]/i.test(trimmed) && /F[\d.]/i.test(trimmed)) {
              result[i] = result[i].replace(
                /F[\d.]+/i,
                'F' + layer0Speed.toFixed(0)
              );
            }
          }
        }
      }
    }

    // Separate mod types
    const zoffsetMods = this.modifications.filter(m => m.type === 'zoffset');
    const layerMods = this.modifications.filter(m => m.type !== 'eject' && m.type !== 'zoffset' && m.type !== 'recovery');
    const ejectMods = this.modifications.filter(m => m.type === 'eject');

    // Apply z-offset modifications by adjusting Z values in affected lines
    if (zoffsetMods.length > 0) {
      // Build a map: for each layer number, compute the total z-offset
      const layerOffsets = new Map();
      for (const layer of parser.layers) {
        let totalOffset = 0;
        for (const mod of zoffsetMods) {
          const startL = mod.layer;
          const endL = mod.endLayer;
          if (layer.number >= startL && (endL == null || layer.number <= endL)) {
            totalOffset += mod.offset;
          }
        }
        if (totalOffset !== 0) layerOffsets.set(layer.number, totalOffset);
      }

      // Walk through lines and adjust Z values in G0/G1/G2/G3 commands
      let currentLayerNum = null;
      for (let i = 0; i < result.length; i++) {
        const trimmed = result[i].trim();

        // Track current layer
        const layerMatch = trimmed.match(/^;LAYER:(\d+)/i);
        if (layerMatch) {
          currentLayerNum = parseInt(layerMatch[1]);
          continue;
        }
        // Bambu format
        const bambuMatch = trimmed.match(/^; layer num\/total_layer_count:\s*(\d+)\/(\d+)/);
        if (bambuMatch) {
          currentLayerNum = parseInt(bambuMatch[1]) - 1;
          continue;
        }

        if (currentLayerNum == null) continue;
        const offset = layerOffsets.get(currentLayerNum);
        if (!offset) continue;

        // Only modify G0/G1/G2/G3 lines that contain a Z parameter
        if (/^G[0123]\s/i.test(trimmed) && /Z[-\d.]/i.test(trimmed)) {
          result[i] = result[i].replace(
            /([Zz])([-\d.]+)/g,
            (match, letter, val) => {
              const newZ = (parseFloat(val) + offset);
              return letter + newZ.toFixed(3);
            }
          );
        }
      }
    }

    // Sort layer mods (including z-offset comments) by layer number (descending) to insert from bottom up
    // This prevents line offset issues
    const sorted = [...layerMods, ...zoffsetMods].sort((a, b) => {
      const la = a.layer === 'end' ? Infinity : a.layer;
      const lb = b.layer === 'end' ? Infinity : b.layer;
      return lb - la;
    });

    for (const mod of sorted) {
      const snippet = this.getSnippet(mod);
      let insertLine;

      if (mod.layer === 'end') {
        insertLine = result.length;
      } else {
        // Skip mods targeting layers that were stripped by recovery
        if (recoveryMod && mod.layer < recoveryMod.resumeLayer) continue;
        const layer = parser.getLayerByNumber(mod.layer);
        if (layer) {
          insertLine = layer.startLine + 1 + recoveryLineShift; // Adjust for recovery line shift
        } else {
          continue; // Skip if layer not found
        }
      }
      result.splice(insertLine, 0, ...snippet);
    }

    // Append eject mods at the very end
    for (const mod of ejectMods) {
      const snippet = this.getSnippet(mod);
      result.push(...snippet);
    }

    return result;
  }
}

// ===== HOLE DETECTOR =====
class HoleDetector {
  constructor() {
    this.resolution = 0.5; // mm per grid cell
    this.lineWidth = 0.45; // extrusion width in mm
    this.gridCache = new Map();
    this.holes = new Map(); // layerNum -> HoleInfo[]
    this.selectedHoles = [];
    this.scannedHoles = []; // flat array of unique holes from full scan
  }

  clearCache() {
    this.gridCache.clear();
    this.holes.clear();
    this.selectedHoles = [];
    this.scannedHoles = [];
  }

  _getGridDims() {
    const b = parser.bounds;
    const w = Math.ceil((b.maxX - b.minX) / this.resolution) + 2;
    const h = Math.ceil((b.maxY - b.minY) / this.resolution) + 2;
    return { w, h, offX: b.minX, offY: b.minY };
  }

  _toGrid(gcodeX, gcodeY, dims) {
    return {
      gx: Math.round((gcodeX - dims.offX) / this.resolution),
      gy: Math.round((gcodeY - dims.offY) / this.resolution)
    };
  }

  _toGcode(gx, gy, dims) {
    return {
      x: gx * this.resolution + dims.offX,
      y: gy * this.resolution + dims.offY
    };
  }

  rasterizeLayer(layerNum, ignoreInfill) {
    const cacheKey = `${layerNum}_${ignoreInfill ? 1 : 0}`;
    if (this.gridCache.has(cacheKey)) return this.gridCache.get(cacheKey);

    const dims = this._getGridDims();
    const grid = new Uint8Array(dims.w * dims.h); // 0 = empty, 1 = filled
    const moves = parser.layerMoves[layerNum];
    if (!moves) { this.gridCache.set(cacheKey, { grid, dims }); return { grid, dims }; }

    const halfW = Math.ceil(this.lineWidth / 2 / this.resolution);

    for (const move of moves) {
      if (!move.extrude) continue;
      // Optionally skip infill
      if (ignoreInfill) {
        const t = move.type.toUpperCase();
        if (t.includes('INFILL') || t.includes('FILL') || t === 'SPARSE' || t === 'SOLID') continue;
      }

      const p0 = this._toGrid(move.x1, move.y1, dims);
      const p1 = this._toGrid(move.x2, move.y2, dims);

      // Bresenham's line with square stamp
      let dx = Math.abs(p1.gx - p0.gx), dy = Math.abs(p1.gy - p0.gy);
      let sx = p0.gx < p1.gx ? 1 : -1, sy = p0.gy < p1.gy ? 1 : -1;
      let err = dx - dy;
      let cx = p0.gx, cy = p0.gy;

      while (true) {
        // Square stamp around current point
        for (let sy2 = -halfW; sy2 <= halfW; sy2++) {
          for (let sx2 = -halfW; sx2 <= halfW; sx2++) {
            const nx = cx + sx2, ny = cy + sy2;
            if (nx >= 0 && nx < dims.w && ny >= 0 && ny < dims.h) {
              grid[ny * dims.w + nx] = 1;
            }
          }
        }
        if (cx === p1.gx && cy === p1.gy) break;
        const e2 = 2 * err;
        if (e2 > -dy) { err -= dy; cx += sx; }
        if (e2 < dx) { err += dx; cy += sy; }
      }
    }

    this.gridCache.set(cacheKey, { grid, dims });
    return { grid, dims };
  }

  detectHoles(layerNum, minDiameterMm, ignoreInfill) {
    minDiameterMm = minDiameterMm || 4;
    const { grid, dims } = this.rasterizeLayer(layerNum, ignoreInfill);
    const w = dims.w, h = dims.h;
    const totalCells = w * h;

    // Labels: 0 = unvisited empty, 1 = filled, 2 = exterior, 3+ = hole IDs
    const labels = new Int32Array(totalCells);
    for (let i = 0; i < totalCells; i++) labels[i] = grid[i] ? 1 : 0;

    // BFS flood-fill from all border cells to mark exterior
    // Use typed-array circular buffer for O(1) enqueue/dequeue
    const queueBuf = new Int32Array(totalCells);
    let qHead = 0, qTail = 0;
    const enqueue = (idx) => { queueBuf[qTail++ % totalCells] = idx; };
    const dequeue = () => queueBuf[qHead++ % totalCells];

    // Seed border cells
    for (let x = 0; x < w; x++) {
      if (labels[x] === 0) { labels[x] = 2; enqueue(x); }
      const botIdx = (h - 1) * w + x;
      if (labels[botIdx] === 0) { labels[botIdx] = 2; enqueue(botIdx); }
    }
    for (let y = 1; y < h - 1; y++) {
      if (labels[y * w] === 0) { labels[y * w] = 2; enqueue(y * w); }
      const rIdx = y * w + w - 1;
      if (labels[rIdx] === 0) { labels[rIdx] = 2; enqueue(rIdx); }
    }

    // BFS to mark all exterior
    const dx4 = [1, -1, 0, 0], dy4 = [0, 0, 1, -1];
    while (qHead < qTail) {
      const idx = dequeue();
      const cx = idx % w, cy = (idx - cx) / w;
      for (let d = 0; d < 4; d++) {
        const nx = cx + dx4[d], ny = cy + dy4[d];
        if (nx < 0 || nx >= w || ny < 0 || ny >= h) continue;
        const nIdx = ny * w + nx;
        if (labels[nIdx] === 0) { labels[nIdx] = 2; enqueue(nIdx); }
      }
    }

    // Find connected components of remaining empty cells (label === 0)
    const holesFound = [];
    let nextLabel = 3;
    for (let i = 0; i < totalCells; i++) {
      if (labels[i] !== 0) continue;
      // BFS for this hole
      const holeLabel = nextLabel++;
      const cells = [];
      qHead = 0; qTail = 0;
      labels[i] = holeLabel;
      enqueue(i);

      while (qHead < qTail) {
        const idx = dequeue();
        cells.push(idx);
        const cx = idx % w, cy = (idx - cx) / w;
        for (let d = 0; d < 4; d++) {
          const nx = cx + dx4[d], ny = cy + dy4[d];
          if (nx < 0 || nx >= w || ny < 0 || ny >= h) continue;
          const nIdx = ny * w + nx;
          if (labels[nIdx] === 0) { labels[nIdx] = holeLabel; enqueue(nIdx); }
        }
      }

      // Compute bbox, centroid, area
      let minGx = Infinity, maxGx = -Infinity, minGy = Infinity, maxGy = -Infinity;
      let sumX = 0, sumY = 0;
      const cellSet = new Set(cells);
      for (const idx of cells) {
        const cx = idx % w, cy = (idx - cx) / w;
        if (cx < minGx) minGx = cx;
        if (cx > maxGx) maxGx = cx;
        if (cy < minGy) minGy = cy;
        if (cy > maxGy) maxGy = cy;
        sumX += cx; sumY += cy;
      }

      const areaMm2 = cells.length * this.resolution * this.resolution;
      const rawDiameter = 2 * Math.sqrt(areaMm2 / Math.PI);
      // Compensate for wall stamp encroachment: the rasterization stamp eats into
      // the hole by ~halfW*resolution on each side, making detected area smaller
      const halfW = Math.ceil(this.lineWidth / 2 / this.resolution);
      const stampCorrection = halfW * this.resolution * 2;
      const diameterMm = rawDiameter + stampCorrection;

      if (diameterMm < minDiameterMm) continue; // Filter small holes

      // Shape classification via bounding-box fill ratio — more reliable on rasterized
      // grids than perimeter-based circularity (grid perimeter overestimates smooth curves
      // by ~4/π, making circles score lower than squares on circularity)
      const bboxW = (maxGx - minGx + 1) * this.resolution + stampCorrection;
      const bboxH = (maxGy - minGy + 1) * this.resolution + stampCorrection;
      const aspect = Math.max(bboxW, bboxH) / Math.max(0.1, Math.min(bboxW, bboxH));
      const rawBboxW = (maxGx - minGx + 1) * this.resolution;
      const rawBboxH = (maxGy - minGy + 1) * this.resolution;
      const rawBboxArea = rawBboxW * rawBboxH;
      const fillRatio = rawBboxArea > 0 ? areaMm2 / rawBboxArea : 0;
      let shape;
      if (aspect < 1.12) {
        // Nearly square bounding box — circle vs square
        shape = fillRatio < 0.9 ? 'circle' : 'square';
      } else if (aspect < 1.3) {
        shape = fillRatio < 0.88 ? 'hexagon' : 'rectangle';
      } else {
        shape = 'rectangle';
      }

      const centroid = this._toGcode(sumX / cells.length, sumY / cells.length, dims);
      const bboxMin = this._toGcode(minGx, minGy, dims);
      const bboxMax = this._toGcode(maxGx, maxGy, dims);

      holesFound.push({
        id: `hole_${layerNum}_${holesFound.length}`,
        label: holeLabel,
        layerNum,
        cells,
        cellSet,
        areaMm2,
        diameterMm,
        shape,
        widthMm: bboxW,
        heightMm: bboxH,
        fillRatio,
        centroid,
        bbox: { minX: bboxMin.x, minY: bboxMin.y, maxX: bboxMax.x, maxY: bboxMax.y },
        gridDims: dims,
        floorLayer: null,
        depthMm: null
      });
    }

    this.holes.set(layerNum, holesFound);
    return holesFound;
  }

  findHoleAtPoint(gcodeX, gcodeY, layerNum) {
    const holes = this.holes.get(layerNum);
    if (!holes) return null;

    for (const hole of holes) {
      if (gcodeX >= hole.bbox.minX && gcodeX <= hole.bbox.maxX &&
          gcodeY >= hole.bbox.minY && gcodeY <= hole.bbox.maxY) {
        // Check if the actual grid cell is part of this hole
        const { gx, gy } = this._toGrid(gcodeX, gcodeY, hole.gridDims);
        const idx = gy * hole.gridDims.w + gx;
        if (hole.cellSet.has(idx)) return hole;
      }
    }
    return null;
  }

  analyzeHoleDepth(hole, startLayerNum) {
    const dims = hole.gridDims;

    // Get footprint cells as a set of (gx, gy) pairs
    const footprint = new Set(hole.cells);
    let floorLayer = -1;

    // Scan layers downward — always include infill when looking for the floor,
    // because the floor of interior holes IS solid infill
    for (let ln = startLayerNum - 1; ln >= 0; ln--) {
      const layer = parser.getLayerByNumber(ln);
      if (!layer) continue;

      const { grid } = this.rasterizeLayer(ln, false);
      // Check what % of footprint cells are filled in this layer
      let filledCount = 0;
      for (const idx of footprint) {
        if (idx >= 0 && idx < grid.length && grid[idx] === 1) filledCount++;
      }

      const overlapRatio = filledCount / footprint.size;
      if (overlapRatio >= 0.8) {
        floorLayer = ln;
        break;
      }
    }

    hole.floorLayer = floorLayer;
    if (floorLayer >= 0) {
      const startLayer = parser.getLayerByNumber(startLayerNum);
      const floorLayerData = parser.getLayerByNumber(floorLayer);
      if (startLayer && floorLayerData && startLayer.zHeight != null && floorLayerData.zHeight != null) {
        hole.depthMm = startLayer.zHeight - floorLayerData.zHeight;
      } else {
        hole.depthMm = null;
      }
    } else {
      hole.depthMm = null; // through-hole
    }

    return hole;
  }

  _holesOverlap(h1, h2) {
    const dx = h1.centroid.x - h2.centroid.x;
    const dy = h1.centroid.y - h2.centroid.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const maxRadius = Math.max(h1.diameterMm, h2.diameterMm) / 2;
    return dist < maxRadius;
  }

  async scanAllLayers(minDiameterMm, ignoreInfill, progressCb) {
    this.scannedHoles = [];
    this.selectedHoles = [];
    const layers = parser.layers;
    const uniqueHoles = [];

    // Scan from top layer to bottom
    for (let i = layers.length - 1; i >= 0; i--) {
      const ln = layers[i].number;
      if (progressCb) progressCb(layers.length - 1 - i, layers.length);

      const layerHoles = this.detectHoles(ln, minDiameterMm, ignoreInfill);

      for (const hole of layerHoles) {
        let matched = false;
        for (const existing of uniqueHoles) {
          if (this._holesOverlap(existing.hole, hole)) {
            matched = true;
            break;
          }
        }
        if (!matched) {
          hole.topLayer = ln;
          uniqueHoles.push({ hole, topLayer: ln });
        }
      }

      // Yield to event loop every 5 layers to keep UI responsive
      if (i % 5 === 0) await new Promise(r => setTimeout(r, 0));
    }

    // Analyze depth for each unique hole
    for (const entry of uniqueHoles) {
      this.analyzeHoleDepth(entry.hole, entry.topLayer);
    }

    this.scannedHoles = uniqueHoles.map(e => e.hole);
    return this.scannedHoles;
  }
}

// ===== INSERT MANAGER =====
class InsertManager {
  constructor() {
    this.inserts = []; // track insert-to-modification links
  }

  clear() { this.inserts = []; }

  calculatePauseLayer(hole, insertHeightMm) {
    if (hole.floorLayer == null || hole.floorLayer < 0) return null;

    const floorLayerData = parser.getLayerByNumber(hole.floorLayer);
    if (!floorLayerData || floorLayerData.zHeight == null) return null;

    const targetZ = floorLayerData.zHeight + insertHeightMm;

    // Find first layer where zHeight >= targetZ
    for (const layer of parser.layers) {
      if (layer.zHeight != null && layer.zHeight >= targetZ) {
        return layer.number;
      }
    }
    return null; // insert taller than remaining print
  }

  createModification(hole, heightMm, diameterMm, label, pauseType, moveHead) {
    const pauseLayer = this.calculatePauseLayer(hole, heightMm);
    if (pauseLayer == null) return null;

    const message = label
      ? `Insert ${label} (${diameterMm}mm dia, ${heightMm}mm tall) at hole #${hole.id}`
      : `Insert object (${diameterMm}mm dia, ${heightMm}mm tall) at hole #${hole.id}`;

    const mod = modifier.addPause(pauseLayer, message, pauseType, moveHead);

    this.inserts.push({
      holeId: hole.id,
      modId: mod.id,
      pauseLayer,
      heightMm,
      diameterMm,
      label
    });

    return { mod, pauseLayer };
  }

  applyToMultipleHoles(holes, config) {
    const results = [];
    for (const hole of holes) {
      const result = this.createModification(
        hole, config.heightMm, config.diameterMm,
        config.label, config.pauseType, config.moveHead
      );
      if (result) results.push(result);
    }
    return results;
  }
}

// ===== UNDO/REDO STACK =====
class UndoStack {
  constructor(maxSize = 50) {
    this.stack = [];
    this.index = -1;
    this.maxSize = maxSize;
  }

  push(state) {
    this.stack = this.stack.slice(0, this.index + 1);
    this.stack.push(JSON.parse(JSON.stringify(state)));
    if (this.stack.length > this.maxSize) this.stack.shift();
    this.index = this.stack.length - 1;
  }

  undo() {
    if (this.index <= 0) return null;
    this.index--;
    return JSON.parse(JSON.stringify(this.stack[this.index]));
  }

  redo() {
    if (this.index >= this.stack.length - 1) return null;
    this.index++;
    return JSON.parse(JSON.stringify(this.stack[this.index]));
  }

  canUndo() { return this.index > 0; }
  canRedo() { return this.index < this.stack.length - 1; }
}

// ===== FIRMWARE PROFILES =====
const FIRMWARE = {
  bambu: {
    name: 'Bambu Lab',
    pause: [
      { value: 'M400U1', label: 'M400 U1 (Bambu)', default: true },
      { value: 'M600', label: 'M600' },
    ],
    pauseHint: 'M400 U1 is recommended for Bambu Lab printers.',
    pauseGcode: {
      'M400U1': 'M400 U1 ; Bambu pause',
      'M600': 'M600 ; Filament change pause',
    },
    filament: [
      { value: 'M1020', label: 'M1020 (AMS)', default: true },
      { value: 'M600', label: 'M600 (Standard)' },
    ],
    filamentHint: 'M1020 triggers AMS filament change with audio notification. M600 is the standard filament change command.',
    hasAMS: true,
    ejectHint: 'Eject commands are appended to the end of the G-code. Loop mode adds a note — true looping requires firmware support or external automation.',
  },
  klipper: {
    name: 'Klipper',
    pause: [
      { value: 'PAUSE', label: 'PAUSE (Macro)', default: true },
      { value: 'M600', label: 'M600' },
      { value: 'M0', label: 'M0' },
    ],
    pauseHint: 'PAUSE calls the [pause_resume] macro. M600 works if defined in your printer.cfg.',
    pauseGcode: {
      'PAUSE': 'PAUSE ; Klipper pause macro',
      'M600': 'M600 ; Filament change',
      'M0': 'M0 ; Pause (unconditional stop)',
    },
    filament: [
      { value: 'M600', label: 'M600', default: true },
    ],
    filamentHint: 'M600 must be defined as a gcode_macro in your printer.cfg. Klipper does not support M600 natively.',
    hasAMS: false,
    ejectHint: 'Eject commands are appended to the end of the G-code. Klipper macros can be used for automation.',
  },
  marlin: {
    name: 'Marlin',
    pause: [
      { value: 'M0', label: 'M0 (Pause)', default: true },
      { value: 'M600', label: 'M600 (Filament Change)' },
      { value: 'M25', label: 'M25 (SD Pause)' },
    ],
    pauseHint: 'M0 pauses and waits for user input. M600 triggers the filament change routine. M25 pauses SD card prints.',
    pauseGcode: {
      'M0': 'M0 ; Pause (Marlin)',
      'M600': 'M600 ; Filament change pause',
      'M25': 'M25 ; Pause SD print',
    },
    filament: [
      { value: 'M600', label: 'M600 (Standard)', default: true },
    ],
    filamentHint: 'M600 triggers the filament change sequence. Enable ADVANCED_PAUSE_FEATURE in Marlin configuration.',
    hasAMS: false,
    ejectHint: 'Eject commands are appended to the end of the G-code. Loop mode adds a note — true looping requires firmware support or external automation.',
  },
  rrf: {
    name: 'RepRapFirmware',
    pause: [
      { value: 'M226', label: 'M226 (Pause)', default: true },
      { value: 'M600', label: 'M600 (Filament Change)' },
      { value: 'M0', label: 'M0 (Stop)' },
    ],
    pauseHint: 'M226 pauses the print and runs the pause.g macro. M0 ends the print and runs stop.g.',
    pauseGcode: {
      'M226': 'M226 ; Pause (RRF)',
      'M600': 'M600 ; Filament change',
      'M0': 'M0 ; Stop print (RRF)',
    },
    filament: [
      { value: 'M600', label: 'M600 (Standard)', default: true },
    ],
    filamentHint: 'M600 triggers a filament change. Define the filament-change.g macro on your SD card.',
    hasAMS: false,
    ejectHint: 'Eject commands are appended to the end of the G-code.',
  },
};

// ===== G-CODE REFERENCE DATA =====
const GCODE_REFERENCE = [
  // ── Movement ──
  { code: 'G0', name: 'Rapid Move', category: 'Movement',
    description: 'Move the print head as fast as possible without extruding. Used for travel moves between print areas. The printer moves all axes simultaneously to reach the target position.',
    params: [
      { letter: 'X', name: 'Target X position on the bed, in millimeters from the left edge', example: '100' },
      { letter: 'Y', name: 'Target Y position on the bed, in millimeters from the front edge', example: '100' },
      { letter: 'Z', name: 'Target Z height above the bed, in millimeters', example: '5' },
      { letter: 'F', name: 'Movement speed in millimeters per minute (mm/min). 6000 = 100mm/s', example: '9000' },
    ],
    example: 'G0 F9000 ; Set travel speed to 150mm/s\nG0 X100 Y100 ; Move nozzle to center of bed\nG0 Z10 ; Raise nozzle 10mm above bed',
    template: 'G0 X__ Y__ F9000',
    firmware: { bambu: null, klipper: null, marlin: 'G0 and G1 behave identically in Marlin — both respect the F parameter.', reprap: null }
  },
  { code: 'G1', name: 'Linear Move', category: 'Movement',
    description: 'Move the print head in a straight line at a controlled speed. This is the most common command — it does all the actual printing. When E is included, filament is pushed through the nozzle as the head moves.',
    params: [
      { letter: 'X', name: 'Target X position in millimeters. In absolute mode (G90), measured from bed origin. In relative mode (G91), distance to move', example: '10.5' },
      { letter: 'Y', name: 'Target Y position in millimeters, same coordinate rules as X', example: '20.0' },
      { letter: 'Z', name: 'Target Z height in millimeters. Typically 0.2mm per layer', example: '0.3' },
      { letter: 'F', name: 'Speed in mm/min. Print moves are typically 600-3000 (10-50mm/s). F sticks until changed', example: '1500' },
      { letter: 'E', name: 'Extruder position in mm of filament. In absolute mode, total since last G92 E0. In relative mode, amount to push for this move', example: '0.5' },
    ],
    example: '; Print a 10mm line along X axis:\nG1 X10 Y0 E0.5 F1500 ; Move 10mm right, extrude 0.5mm of filament at 25mm/s\n; Move to next layer:\nG1 Z0.4 F600 ; Raise nozzle to 0.4mm (layer 2 at 0.2mm height)\n; Retraction (pull filament back to prevent oozing):\nG1 E-1.0 F2400 ; Retract 1mm of filament at 40mm/s',
    template: 'G1 X__ Y__ Z__ F1500 E__',
    firmware: { bambu: null, klipper: null, marlin: null, reprap: null }
  },
  { code: 'G2', name: 'Clockwise Arc', category: 'Movement',
    description: 'Move in a clockwise arc. I and J are the offsets from the current position to the center of the arc. The nozzle traces the arc from where it is now to the X,Y endpoint.',
    params: [
      { letter: 'X', name: 'End X position of the arc in mm', example: '10' },
      { letter: 'Y', name: 'End Y position of the arc in mm', example: '20' },
      { letter: 'I', name: 'X offset from current position to arc center, in mm. Positive = right of current pos', example: '5' },
      { letter: 'J', name: 'Y offset from current position to arc center, in mm. Positive = behind current pos', example: '0' },
      { letter: 'E', name: 'Extruder position in mm (how much filament to extrude over the arc)', example: '1.2' },
      { letter: 'F', name: 'Speed in mm/min', example: '1200' },
    ],
    example: '; Draw a half circle (180\u00b0) with 5mm radius:\n; Starting at X0 Y0, center at X5 Y0, ending at X10 Y0\nG2 X10 Y0 I5 J0 F1200 E0.8\n; Draw a full circle with 10mm radius:\nG2 I10 J0 F1200 E3.14',
    template: 'G2 X__ Y__ I__ J__ F1200',
    firmware: { bambu: 'Bambu Lab firmware supports arc commands natively.', klipper: 'Enable arc support with [gcode_arcs] in printer.cfg.', marlin: 'Enable ARC_SUPPORT in Configuration_adv.h.', reprap: null }
  },
  { code: 'G3', name: 'Counter-Clockwise Arc', category: 'Movement',
    description: 'Same as G2, but the arc goes counter-clockwise. All parameters work identically.',
    params: [
      { letter: 'X', name: 'End X position of the arc in mm', example: '10' },
      { letter: 'Y', name: 'End Y position of the arc in mm', example: '20' },
      { letter: 'I', name: 'X offset from current position to arc center, in mm', example: '5' },
      { letter: 'J', name: 'Y offset from current position to arc center, in mm', example: '0' },
      { letter: 'E', name: 'Extruder position in mm', example: '1.2' },
      { letter: 'F', name: 'Speed in mm/min', example: '1200' },
    ],
    example: '; Counter-clockwise half circle:\nG3 X10 Y0 I5 J0 F1200 E0.8',
    template: 'G3 X__ Y__ I__ J__ F1200',
    firmware: { bambu: null, klipper: 'Enable arc support with [gcode_arcs] in printer.cfg.', marlin: 'Enable ARC_SUPPORT in Configuration_adv.h.', reprap: null }
  },
  { code: 'G28', name: 'Home Axes', category: 'Movement',
    description: 'Move the print head to the home position (0,0,0) using the endstop switches. With no parameters, homes all three axes. You can home individual axes by specifying them.',
    params: [
      { letter: 'X', name: 'Home only the X axis (no value needed)', example: '' },
      { letter: 'Y', name: 'Home only the Y axis (no value needed)', example: '' },
      { letter: 'Z', name: 'Home only the Z axis (no value needed)', example: '' },
    ],
    example: 'G28 ; Home all axes (X, Y, and Z)\nG28 X Y ; Home only X and Y, leave Z where it is\nG28 Z ; Home only Z axis',
    template: 'G28',
    firmware: { bambu: null, klipper: 'Uses [homing_override] or [safe_z_home] if configured.', marlin: null, reprap: null }
  },
  { code: 'G90', name: 'Absolute Positioning', category: 'Movement',
    description: 'Switch to absolute positioning. All X/Y/Z values in G0/G1 are measured from the bed origin (0,0,0). This is the default mode — "G1 X50" means "go to position 50mm".',
    params: [],
    example: 'G90 ; Switch to absolute mode\nG1 X50 Y50 ; Move to (50, 50) on the bed\nG1 X100 ; Move to X=100 (not 100mm further)',
    template: 'G90',
    firmware: { bambu: null, klipper: null, marlin: null, reprap: 'In RepRapFirmware, G90 also affects the extruder. Use M82/M83 to set extruder mode independently.' }
  },
  { code: 'G91', name: 'Relative Positioning', category: 'Movement',
    description: 'Switch to relative (incremental) positioning. All X/Y/Z values are distances to move from the current position. "G1 X50" means "move 50mm to the right". Remember to switch back to G90 when done.',
    params: [],
    example: '; Lift nozzle 5mm and move aside (common pause sequence):\nG91 ; Switch to relative\nG1 Z5 F600 ; Lift nozzle 5mm\nG1 X-10 Y-10 F3000 ; Move 10mm left and 10mm forward\nG90 ; Switch back to absolute',
    template: 'G91\nG1 Z5 F600\nG90',
    firmware: { bambu: null, klipper: null, marlin: null, reprap: 'In RepRapFirmware, G91 also affects the extruder.' }
  },
  { code: 'G92', name: 'Set Position', category: 'Movement',
    description: 'Tell the printer "you are now at this position" without actually moving. Most commonly used as G92 E0 to reset the extruder counter to zero (prevents E values from getting very large).',
    params: [
      { letter: 'X', name: 'Set current X position to this value (mm)', example: '0' },
      { letter: 'Y', name: 'Set current Y position to this value (mm)', example: '0' },
      { letter: 'Z', name: 'Set current Z position to this value (mm)', example: '0' },
      { letter: 'E', name: 'Set current extruder position to this value (mm). E0 resets the counter', example: '0' },
    ],
    example: 'G92 E0 ; Reset extruder to zero (most common use)\n; After a filament change, if you need to recalibrate Z:\nG92 Z10.2 ; Tell printer current Z is 10.2mm',
    template: 'G92 E0',
    firmware: { bambu: null, klipper: null, marlin: null, reprap: null }
  },

  // ── Temperature ──
  { code: 'M104', name: 'Set Hotend Temperature', category: 'Temperature',
    description: 'Start heating the nozzle and continue immediately — does NOT wait. The printer keeps executing commands while heating. Use M109 if you need to wait for the temperature before printing.',
    params: [
      { letter: 'S', name: 'Target temperature in degrees Celsius (\u00b0C). Common values: PLA=200, PETG=230, ABS=250', example: '200' },
      { letter: 'T', name: 'Extruder number (0-based) for multi-extruder printers. Default is 0', example: '0' },
    ],
    example: '; Start preheating while doing other things:\nM104 S200 ; Begin heating nozzle to 200\u00b0C\nG28 ; Home axes while nozzle heats up\nM109 S200 ; Now wait for it to reach 200\u00b0C',
    template: 'M104 S200',
    firmware: { bambu: null, klipper: null, marlin: null, reprap: null }
  },
  { code: 'M109', name: 'Wait for Hotend Temperature', category: 'Temperature',
    description: 'Set the nozzle temperature and WAIT until it reaches the target before continuing. The printer will not execute any more commands until the temperature is reached. This blocks the print.',
    params: [
      { letter: 'S', name: 'Target temp in \u00b0C — waits for heating only (if nozzle is hotter, it does not wait to cool down)', example: '200' },
      { letter: 'R', name: 'Target temp in \u00b0C — waits for EXACT temp (waits for both heating AND cooling)', example: '200' },
    ],
    example: '; Wait for PLA temperature:\nM109 S200 ; Heat to 200\u00b0C and wait\n; Wait for exact temperature (useful after switching materials):\nM109 R180 ; Wait until nozzle is exactly 180\u00b0C, even if cooling down',
    template: 'M109 S200',
    firmware: { bambu: null, klipper: null, marlin: 'S waits only for heating. R waits for both heating and cooling.', reprap: null }
  },
  { code: 'M140', name: 'Set Bed Temperature', category: 'Temperature',
    description: 'Start heating the print bed and continue immediately — does NOT wait. Beds heat slowly (can take several minutes), so start early. Use M190 to wait.',
    params: [
      { letter: 'S', name: 'Target bed temperature in \u00b0C. Common values: PLA=60, PETG=70, ABS=100', example: '60' },
    ],
    example: '; Preheat bed early (beds are slow to heat):\nM140 S60 ; Start heating bed to 60\u00b0C\nM104 S200 ; Also start heating nozzle\nG28 ; Home while everything heats\nM190 S60 ; Now wait for bed\nM109 S200 ; Then wait for nozzle',
    template: 'M140 S60',
    firmware: { bambu: null, klipper: null, marlin: null, reprap: null }
  },
  { code: 'M190', name: 'Wait for Bed Temperature', category: 'Temperature',
    description: 'Set the bed temperature and WAIT until reached. Can take 2-5 minutes depending on target. Usually paired with M140 for efficient preheating.',
    params: [
      { letter: 'S', name: 'Target bed temp in \u00b0C — waits for heating only', example: '60' },
      { letter: 'R', name: 'Target bed temp in \u00b0C — waits for exact temp (heating or cooling)', example: '60' },
    ],
    example: 'M190 S60 ; Heat bed to 60\u00b0C and wait\nM190 R45 ; Wait for bed to cool to exactly 45\u00b0C',
    template: 'M190 S60',
    firmware: { bambu: null, klipper: null, marlin: null, reprap: null }
  },
  { code: 'M106', name: 'Set Fan Speed', category: 'Temperature',
    description: 'Control the part cooling fan. The fan blows on the printed plastic to cool it quickly. Speed is 0-255 where 0=off and 255=full blast. To convert percentage: multiply by 2.55 (50% = 128).',
    params: [
      { letter: 'S', name: 'Fan speed from 0 (off) to 255 (100%). Examples: 64=25%, 128=50%, 191=75%, 255=100%', example: '255' },
      { letter: 'P', name: 'Fan index for multi-fan setups. P0 = part cooling fan (default), P1/P2 = auxiliary fans', example: '0' },
    ],
    example: 'M106 S255 ; Fan at 100% (max cooling, good for PLA)\nM106 S128 ; Fan at 50% (good for PETG bridges)\nM106 S0 ; Fan off (same as M107)\n; For Bambu Lab auxiliary fan:\nM106 P1 S255 ; Turn on aux fan at full speed',
    template: 'M106 S255',
    firmware: { bambu: 'P0 = part cooling fan, P1 = auxiliary fan, P2 = chamber fan.', klipper: 'Fan must be defined as [fan] in printer.cfg. Additional fans use [fan_generic].', marlin: null, reprap: null }
  },
  { code: 'M107', name: 'Fan Off', category: 'Temperature',
    description: 'Turn off the part cooling fan completely. Shortcut for M106 S0.',
    params: [],
    example: '; Turn fan off for first few layers (better bed adhesion):\nM107 ; Fan off\n; ... print first 3 layers ...\nM106 S255 ; Fan on for remaining layers',
    template: 'M107',
    firmware: { bambu: null, klipper: null, marlin: null, reprap: null }
  },

  // ── Extrusion ──
  { code: 'M82', name: 'Absolute Extrusion', category: 'Extrusion',
    description: 'Set the extruder to absolute mode. The E value in G1 commands is the total filament pushed since the last G92 E0 reset. Most slicers use this mode. Example: E10 means "10mm total extruded so far".',
    params: [],
    example: 'M82 ; Use absolute extrusion\nG92 E0 ; Reset E counter to zero\nG1 X10 E0.5 ; Extrude 0.5mm total\nG1 X20 E1.0 ; Extrude 0.5mm more (1.0 - 0.5 = 0.5mm for this move)\nG1 X30 E1.5 ; Extrude 0.5mm more (1.5 - 1.0 = 0.5mm for this move)',
    template: 'M82',
    firmware: { bambu: null, klipper: null, marlin: null, reprap: 'In RepRapFirmware, M82 overrides G90/G91 for the extruder axis specifically.' }
  },
  { code: 'M83', name: 'Relative Extrusion', category: 'Extrusion',
    description: 'Set the extruder to relative mode. Each E value is the amount of filament to push for THAT move only. Example: E0.5 means "push 0.5mm of filament during this move". No need to track running totals.',
    params: [],
    example: 'M83 ; Use relative extrusion\nG1 X10 E0.5 ; Push 0.5mm of filament\nG1 X20 E0.5 ; Push another 0.5mm\nG1 E-1.0 F2400 ; Retract 1mm (negative = pull back)',
    template: 'M83',
    firmware: { bambu: null, klipper: 'Klipper recommends relative extrusion for better pressure advance behavior.', marlin: null, reprap: null }
  },

  // ── Print Control ──
  { code: 'M0', name: 'Unconditional Stop', category: 'Print Control',
    description: 'Pause the print and wait for user to press a button on the LCD/touchscreen. The printer stops all movement and waits indefinitely (or until timeout).',
    params: [
      { letter: 'S', name: 'Optional timeout in seconds. After this many seconds, the print resumes automatically. Omit for indefinite pause', example: '30' },
    ],
    example: '; Pause to insert a magnet:\nM0 ; Pause — press button on LCD to resume\n; Pause with 60 second timeout:\nM0 S60 ; Auto-resume after 60 seconds if no button press',
    template: 'M0',
    firmware: { bambu: 'Not recommended for Bambu Lab \u2014 use M400 U1 instead.', klipper: 'M0 is supported but PAUSE macro is preferred.', marlin: 'Requires LCD or host connection to resume.', reprap: null }
  },
  { code: 'M25', name: 'Pause SD Print', category: 'Print Control',
    description: 'Pause a print that is running from the SD card or USB drive. Has no effect on prints streamed from a host computer (OctoPrint, etc.).',
    params: [],
    example: 'M25 ; Pause the SD card print',
    template: 'M25',
    firmware: { bambu: null, klipper: 'Not commonly used in Klipper \u2014 use PAUSE macro instead.', marlin: 'Only works for SD prints. For host prints, use M0 or M600.', reprap: null }
  },
  { code: 'M226', name: 'Wait for Pin / Pause', category: 'Print Control',
    description: 'In RepRapFirmware, pauses the print (like pressing Pause in the web interface). In Marlin, waits for a specific pin to change state (different behavior!).',
    params: [],
    example: '; RepRapFirmware: Pause for manual intervention\nM226 ; Pauses print, runs pause.g macro',
    template: 'M226',
    firmware: { bambu: 'Not supported on Bambu Lab.', klipper: 'Not supported in Klipper \u2014 use PAUSE macro.', marlin: 'In Marlin, M226 waits for a pin state, not a pause command.', reprap: 'Primary pause command in RepRapFirmware. Runs the pause.g macro.' }
  },
  { code: 'M600', name: 'Filament Change', category: 'Print Control',
    description: 'Initiate a filament change sequence. The printer will: 1) retract filament, 2) move the nozzle out of the way, 3) wait for you to swap filament, 4) prime the new filament, 5) resume printing.',
    params: [
      { letter: 'E', name: 'Initial retraction length in mm (how much to pull back before parking). Default varies by firmware', example: '3' },
      { letter: 'L', name: 'Filament load length in mm (how much to push when loading new filament)', example: '50' },
      { letter: 'X', name: 'Park X position in mm (where the nozzle moves to during change)', example: '10' },
      { letter: 'Y', name: 'Park Y position in mm', example: '10' },
      { letter: 'Z', name: 'Z lift in mm (how much to raise nozzle above print)', example: '5' },
    ],
    example: '; Basic filament change (uses firmware defaults):\nM600 ; Retract, park, wait for user, reload, resume\n; Filament change with custom park position:\nM600 X10 Y10 Z5 ; Park at front-left corner, lift 5mm\n; With custom retract and load lengths:\nM600 E4 L80 ; Retract 4mm, load 80mm of new filament',
    template: 'M600',
    firmware: { bambu: 'Supported but M1020 is preferred for AMS filament changes.', klipper: 'Must be defined as a [gcode_macro M600] in printer.cfg.', marlin: 'Requires ADVANCED_PAUSE_FEATURE enabled in Configuration_adv.h.', reprap: 'Runs the filament-change.g macro file.' }
  },
  { code: 'M400', name: 'Wait for Moves to Finish', category: 'Print Control',
    description: 'Wait until all buffered movement commands have finished executing. The printer buffers ahead for smooth motion — M400 forces it to fully catch up. Use before pauses or temperature changes.',
    params: [],
    example: '; Ensure nozzle is in position before pausing:\nG1 X50 Y50 F3000 ; Move to center\nM400 ; Wait for move to actually complete\nM0 ; Now pause (nozzle is definitely at 50,50)',
    template: 'M400',
    firmware: { bambu: null, klipper: null, marlin: null, reprap: null }
  },
  { code: 'M400 U1', name: 'Bambu Lab Pause', category: 'Print Control',
    description: 'Bambu Lab-specific pause. Shows a pop-up dialog on the touchscreen with an audio alert. This is the recommended pause method for all Bambu Lab printers (X1, P1, A1 series).',
    params: [],
    example: '; Pause for insert placement on Bambu Lab:\nG91 ; Relative mode\nG1 Z5 F600 ; Lift nozzle 5mm\nG90 ; Absolute mode\nG1 X5 Y5 F6000 ; Move to front corner\nM400 U1 ; Show pause dialog on touchscreen',
    template: 'M400 U1',
    firmware: { bambu: 'Recommended pause command for all Bambu Lab printers.', klipper: 'Not supported \u2014 use PAUSE macro instead.', marlin: 'Not supported \u2014 use M0 or M600.', reprap: 'Not supported \u2014 use M226.' }
  },
  { code: 'PAUSE', name: 'Klipper Pause Macro', category: 'Print Control',
    description: 'Klipper-specific pause macro. Behavior (park position, retraction amount, speed) is defined in your printer.cfg. Much more customizable than M0.',
    params: [],
    example: '; Simple Klipper pause:\nPAUSE ; Runs your configured pause sequence\n; To resume, use RESUME command or UI button',
    template: 'PAUSE',
    firmware: { bambu: 'Not supported \u2014 use M400 U1.', klipper: 'Requires [pause_resume] in printer.cfg. Customize with gcode_macro.', marlin: 'Not supported \u2014 use M0 or M600.', reprap: 'Not supported \u2014 use M226.' }
  },

  // ── Calibration & Leveling ──
  { code: 'G29', name: 'Auto Bed Leveling', category: 'Calibration & Leveling',
    description: 'Probe multiple points across the bed to create a mesh that compensates for an uneven surface. The probe measures the distance at each point and the firmware adjusts Z during printing. Always home (G28) first.',
    params: [],
    example: '; Typical bed leveling sequence:\nG28 ; Home all axes first (required!)\nG29 ; Probe the bed and create mesh\n; The mesh is now active — Z will auto-adjust during printing',
    template: 'G28\nG29',
    firmware: { bambu: 'Bambu Lab printers auto-level before each print. Manual G29 is not typically needed.', klipper: 'Use BED_MESH_CALIBRATE instead. G29 is not a native Klipper command.', marlin: 'Requires a probe (BLTouch, inductive, etc.) and AUTO_BED_LEVELING enabled.', reprap: 'Runs the bed.g macro to probe the bed.' }
  },
  { code: 'M48', name: 'Probe Repeatability Test', category: 'Calibration & Leveling',
    description: 'Test your Z-probe accuracy by probing the same spot multiple times. Reports the standard deviation — lower is better. A good probe should be under 0.01mm.',
    params: [
      { letter: 'P', name: 'Number of times to probe (more = more accurate test). Default is usually 10', example: '10' },
    ],
    example: '; Test probe accuracy with 10 samples:\nG28 ; Home first\nM48 P10 ; Probe 10 times, report std deviation\n; Good result: StdDev < 0.01mm\n; Bad result: StdDev > 0.03mm (probe needs adjustment)',
    template: 'M48 P10',
    firmware: { bambu: null, klipper: 'Use PROBE_ACCURACY command instead.', marlin: 'Requires Z_MIN_PROBE_REPEATABILITY_TEST enabled.', reprap: null }
  },
  { code: 'M500', name: 'Save Settings to EEPROM', category: 'Calibration & Leveling',
    description: 'Save current settings (steps/mm, PID values, Z-offset, acceleration, etc.) to permanent memory. Settings survive power cycles. Use after calibration so you don\'t have to recalibrate every time.',
    params: [],
    example: '; After PID tuning, save the results:\nM303 S200 E0 C8 ; Run PID autotune\nM301 P22.2 I1.08 D114.0 ; Apply the values\nM500 ; Save to EEPROM (survives power off)',
    template: 'M500',
    firmware: { bambu: null, klipper: 'Klipper uses SAVE_CONFIG instead of M500.', marlin: 'Requires EEPROM_SETTINGS enabled in Configuration.h.', reprap: 'Saves to config-override.g.' }
  },
  { code: 'M501', name: 'Load Settings from EEPROM', category: 'Calibration & Leveling',
    description: 'Load previously saved settings from EEPROM, overriding anything changed since boot. Useful to undo accidental changes without restarting.',
    params: [],
    example: '; Oops, changed acceleration wrong — reload saved settings:\nM501 ; Restore all saved values from EEPROM',
    template: 'M501',
    firmware: { bambu: null, klipper: 'Not applicable \u2014 Klipper reads printer.cfg at startup.', marlin: null, reprap: 'Runs config-override.g.' }
  },
  { code: 'M503', name: 'Report Settings', category: 'Calibration & Leveling',
    description: 'Print all current firmware settings to the serial console. Handy for checking your steps/mm, PID values, max speeds, and other config without opening firmware files.',
    params: [],
    example: 'M503 ; Dump all settings to console\n; Look for lines like:\n;   M92 X80 Y80 Z400 E93 (steps/mm)\n;   M301 P22.2 I1.08 D114 (PID values)',
    template: 'M503',
    firmware: { bambu: null, klipper: 'Not applicable \u2014 settings are in printer.cfg.', marlin: null, reprap: null }
  },

  // ── Stepper & Motion ──
  { code: 'M84', name: 'Disable Steppers', category: 'Stepper & Motion',
    description: 'Turn off the stepper motors so the print head and bed can be moved by hand. Usually the last command in a print file. Caution: the nozzle will drop if Z is disabled while raised.',
    params: [
      { letter: 'S', name: 'Idle timeout in seconds — steppers auto-disable after this many seconds of inactivity', example: '120' },
    ],
    example: 'M84 ; Disable all steppers immediately\nM84 S120 ; Auto-disable after 120 seconds of idle',
    template: 'M84',
    firmware: { bambu: null, klipper: null, marlin: 'Also accessible as M18.', reprap: null }
  },
  { code: 'M201', name: 'Set Max Acceleration', category: 'Stepper & Motion',
    description: 'Set the maximum allowed acceleration for each axis. Higher = faster direction changes but more vibration/ringing. Units are mm/s\u00b2 (millimeters per second squared).',
    params: [
      { letter: 'X', name: 'X axis max acceleration in mm/s\u00b2. Typical: 500-3000', example: '1000' },
      { letter: 'Y', name: 'Y axis max acceleration in mm/s\u00b2. Usually same as X', example: '1000' },
      { letter: 'Z', name: 'Z axis max acceleration in mm/s\u00b2. Usually low (50-200) since Z moves are slow', example: '100' },
      { letter: 'E', name: 'Extruder max acceleration in mm/s\u00b2. Typical: 1000-10000', example: '5000' },
    ],
    example: '; Reduce acceleration for better print quality:\nM201 X500 Y500 ; Halve XY accel (less ringing)\n; Increase for speed:\nM201 X3000 Y3000 ; Higher accel (faster but may ring)',
    template: 'M201 X1000 Y1000 Z100 E5000',
    firmware: { bambu: null, klipper: 'Use SET_VELOCITY_LIMIT ACCEL=value instead.', marlin: null, reprap: null }
  },
  { code: 'M203', name: 'Set Max Feedrate', category: 'Stepper & Motion',
    description: 'Set the absolute maximum speed for each axis. The printer will never exceed these speeds even if the G-code requests faster. Units are mm/s (millimeters per second).',
    params: [
      { letter: 'X', name: 'X max speed in mm/s. Typical: 150-500', example: '200' },
      { letter: 'Y', name: 'Y max speed in mm/s. Usually same as X', example: '200' },
      { letter: 'Z', name: 'Z max speed in mm/s. Usually 5-20 (Z is slow)', example: '5' },
      { letter: 'E', name: 'Extruder max speed in mm/s. Typical: 25-100', example: '50' },
    ],
    example: '; Cap speeds for quiet printing:\nM203 X100 Y100 ; Limit to 100mm/s\n; Increase Z speed for faster layer changes:\nM203 Z10 ; Allow Z to move at 10mm/s',
    template: 'M203 X200 Y200 Z5 E50',
    firmware: { bambu: null, klipper: 'Use SET_VELOCITY_LIMIT VELOCITY=value instead.', marlin: null, reprap: null }
  },
  { code: 'M204', name: 'Set Default Acceleration', category: 'Stepper & Motion',
    description: 'Set the default acceleration used for different types of moves. Print moves are slower (better quality), travel moves are faster (save time), retract can be fastest.',
    params: [
      { letter: 'P', name: 'Print move acceleration in mm/s\u00b2. Used when extruding. Typical: 500-2000', example: '1000' },
      { letter: 'T', name: 'Travel move acceleration in mm/s\u00b2. Used for non-printing moves. Typical: 1000-5000', example: '2000' },
      { letter: 'R', name: 'Retraction acceleration in mm/s\u00b2. Used for E-only moves. Typical: 1000-5000', example: '3000' },
    ],
    example: '; Slow down printing acceleration for quality:\nM204 P800 T2000 ; Gentle prints, fast travels\n; Speed up for draft prints:\nM204 P2000 T5000 ; Aggressive acceleration',
    template: 'M204 P1000 T2000',
    firmware: { bambu: null, klipper: 'Use SET_VELOCITY_LIMIT ACCEL=value. Klipper uses a single acceleration value.', marlin: null, reprap: null }
  },
  { code: 'M205', name: 'Set Jerk / Junction Deviation', category: 'Stepper & Motion',
    description: 'Set jerk limits — the maximum speed the printer can instantly change direction at. Lower values = smoother prints but slower corners. Higher values = faster corners but more vibration.',
    params: [
      { letter: 'X', name: 'X jerk in mm/s — max instant speed change for X axis. Typical: 5-15', example: '8' },
      { letter: 'Y', name: 'Y jerk in mm/s. Usually same as X', example: '8' },
      { letter: 'Z', name: 'Z jerk in mm/s. Usually very low (0.2-0.5)', example: '0.4' },
      { letter: 'E', name: 'Extruder jerk in mm/s. Typical: 2-10', example: '5' },
      { letter: 'J', name: 'Junction deviation in mm (modern alternative to jerk). Typical: 0.01-0.02', example: '0.013' },
    ],
    example: '; Reduce jerk for quieter, smoother printing:\nM205 X5 Y5 ; Lower jerk = less vibration\n; Increase for speed (may cause ringing):\nM205 X12 Y12 ; Higher jerk = faster corners',
    template: 'M205 X8 Y8 Z0.4 E5',
    firmware: { bambu: null, klipper: 'Klipper uses square_corner_velocity in printer.cfg instead of jerk.', marlin: 'J parameter enables Junction Deviation mode (alternative to classic jerk).', reprap: 'RepRapFirmware uses M566 for jerk settings, not M205.' }
  },
  { code: 'M220', name: 'Set Speed Factor', category: 'Stepper & Motion',
    description: 'Override ALL print speeds as a percentage. Like the speed dial on your printer. 100% = normal, 50% = half speed, 200% = double speed. Useful for slowing down tricky sections mid-print.',
    params: [
      { letter: 'S', name: 'Speed as a percentage. 100 = normal speed. Range: 10-999', example: '100' },
    ],
    example: 'M220 S50 ; Half speed (50%) — for tricky overhangs\nM220 S100 ; Back to normal speed\nM220 S150 ; 50% faster than normal',
    template: 'M220 S100',
    firmware: { bambu: null, klipper: null, marlin: null, reprap: null }
  },
  { code: 'M221', name: 'Set Flow Rate', category: 'Stepper & Motion',
    description: 'Override the extrusion flow rate as a percentage. Adjusts how much plastic comes out. Useful for fine-tuning: 95% if over-extruding, 105% if under-extruding.',
    params: [
      { letter: 'S', name: 'Flow as a percentage. 100 = normal flow. Common adjustments: 90-110', example: '100' },
    ],
    example: 'M221 S95 ; Reduce flow to 95% (fixing slight over-extrusion)\nM221 S100 ; Back to normal flow\nM221 S105 ; Increase flow to 105% (filling gaps)',
    template: 'M221 S100',
    firmware: { bambu: null, klipper: 'Use SET_PRESSURE_ADVANCE for flow tuning instead.', marlin: null, reprap: null }
  },

  // ── Filament & Material ──
  { code: 'M1020', name: 'Bambu AMS Filament Change', category: 'Filament & Material',
    description: 'Bambu Lab-specific command to switch which filament the AMS (Automatic Material System) feeds. The AMS has 4 slots numbered 0-3. Plays an audio notification when changing.',
    params: [
      { letter: 'S', name: 'AMS slot number (0-3). S0 = Slot 1, S1 = Slot 2, S2 = Slot 3, S3 = Slot 4', example: '1' },
    ],
    example: '; Switch to second AMS slot (red filament):\nM1020 S1 ; Load from AMS slot 2\n; Switch back to first slot (white filament):\nM1020 S0 ; Load from AMS slot 1',
    template: 'M1020 S0',
    firmware: { bambu: 'Primary AMS filament change command. Slots: S0=slot 1, S1=slot 2, S2=slot 3, S3=slot 4.', klipper: 'Not supported \u2014 Bambu Lab specific.', marlin: 'Not supported \u2014 Bambu Lab specific.', reprap: 'Not supported \u2014 Bambu Lab specific.' }
  },
  { code: 'T0', name: 'Select Extruder', category: 'Filament & Material',
    description: 'Select which extruder to use on multi-extruder printers. T0 = first extruder, T1 = second, T2 = third, etc. Used for dual-color or multi-material printing.',
    params: [],
    example: '; Switch between extruders for dual-color print:\nT0 ; Use first extruder (e.g., white PLA)\nG1 X50 Y50 E10 ; Print with extruder 0\nT1 ; Switch to second extruder (e.g., black PLA)\nG1 X60 Y50 E10 ; Print with extruder 1',
    template: 'T0',
    firmware: { bambu: 'Bambu Lab uses T commands internally with AMS.', klipper: 'Requires [extruder] and [extruder1] etc. in printer.cfg.', marlin: 'Requires EXTRUDERS > 1 in Configuration.h.', reprap: 'Runs the tool-change macro (tpre0.g, tpost0.g, tfree0.g).' }
  },

  // ── Display & Communication ──
  { code: 'M117', name: 'Set LCD Message', category: 'Display & Communication',
    description: 'Display a custom message on the printer\'s LCD/touchscreen. Great for showing layer count, time remaining, or reminders. The message stays until replaced by another M117.',
    params: [
      { letter: '', name: 'Message text — everything after "M117 " is displayed. No quotes needed', example: 'Layer 50 of 200' },
    ],
    example: 'M117 Printing base layers ; Show status\nM117 Insert magnet NOW! ; Show reminder\nM117 ; Clear the message (empty)',
    template: 'M117 Your message here',
    firmware: { bambu: 'May not display on Bambu Lab touchscreen.', klipper: 'Requires [display] in printer.cfg. Also supports SET_DISPLAY_TEXT.', marlin: null, reprap: 'Displays on PanelDue or web interface.' }
  },
  { code: 'M118', name: 'Serial Message', category: 'Display & Communication',
    description: 'Send a text message to the connected host software (OctoPrint, Mainsail, Pronterface, etc.). Useful for logging, triggering plugins, or debugging G-code scripts.',
    params: [
      { letter: '', name: 'Message text — sent to the host over serial/USB', example: 'Print checkpoint reached' },
    ],
    example: 'M118 Starting layer 50 ; Log message to host\nM118 Filament change needed ; Alert the host software',
    template: 'M118 Message here',
    firmware: { bambu: null, klipper: 'Use RESPOND MSG="text" for Klipper host messaging.', marlin: null, reprap: null }
  },
  { code: 'M73', name: 'Set Print Progress', category: 'Display & Communication',
    description: 'Tell the printer how far along the print is (percentage) and estimated time remaining. Slicers usually insert these automatically. The printer displays this info on the LCD.',
    params: [
      { letter: 'P', name: 'Progress percentage, 0 to 100', example: '50' },
      { letter: 'R', name: 'Remaining time in minutes. 30 = about 30 minutes left', example: '30' },
    ],
    example: 'M73 P0 R120 ; 0% done, about 2 hours remaining\nM73 P50 R60 ; 50% done, about 1 hour left\nM73 P100 R0 ; 100% complete',
    template: 'M73 P__ R__',
    firmware: { bambu: 'Bambu Lab uses this to display progress on the touchscreen.', klipper: 'Supported with [display] and SET_DISPLAY_TEXT.', marlin: 'Requires SET_PROGRESS_MANUALLY enabled.', reprap: null }
  },

  // ── PID & Advanced ──
  { code: 'M303', name: 'PID Autotune', category: 'PID & Advanced',
    description: 'Automatically calibrate the PID temperature control for the hotend or bed. The printer cycles the heater on and off, measures the response, and calculates optimal P/I/D values for stable temperature.',
    params: [
      { letter: 'S', name: 'Target temperature in \u00b0C to tune at. Use your normal printing temp (e.g., 200 for PLA)', example: '200' },
      { letter: 'E', name: 'Heater index: 0 = hotend (default), -1 = heated bed', example: '0' },
      { letter: 'C', name: 'Number of heating cycles. More cycles = more accurate. 5-10 recommended', example: '8' },
    ],
    example: '; Tune hotend PID at 200\u00b0C:\nM303 S200 E0 C8 ; 8 cycles at 200\u00b0C\n; Printer will output values like: Kp=22.2 Ki=1.08 Kd=114.0\n; Apply them: M301 P22.2 I1.08 D114.0\n; Save: M500\n\n; Tune bed PID at 60\u00b0C:\nM303 S60 E-1 C8 ; E-1 = bed heater',
    template: 'M303 S200 E0 C8',
    firmware: { bambu: 'Bambu Lab printers have factory-tuned PID. Manual tuning is not recommended.', klipper: 'Use PID_CALIBRATE HEATER=extruder TARGET=200 instead.', marlin: 'After tuning, apply values with M301 (hotend) or M304 (bed), then M500 to save.', reprap: 'Use M303 H1 S200 for the hotend heater.' }
  },
  { code: 'M301', name: 'Set Hotend PID', category: 'PID & Advanced',
    description: 'Set the PID control parameters for the hotend heater. These values determine how accurately the nozzle holds temperature. Get values from M303 autotune. Save with M500.',
    params: [
      { letter: 'P', name: 'Proportional gain (Kp) — how aggressively to heat. Higher = faster response but may overshoot', example: '22.2' },
      { letter: 'I', name: 'Integral gain (Ki) — corrects long-term drift. Too high = oscillation', example: '1.08' },
      { letter: 'D', name: 'Derivative gain (Kd) — dampens overshoot. Higher = smoother but slower', example: '114.0' },
    ],
    example: '; Apply PID values from autotune:\nM301 P22.2 I1.08 D114.0\nM500 ; Save to EEPROM so they survive reboot',
    template: 'M301 P__ I__ D__',
    firmware: { bambu: 'Not user-configurable on Bambu Lab.', klipper: 'PID values are set in printer.cfg under [extruder] section.', marlin: 'Save to EEPROM with M500 after setting.', reprap: 'Use M307 for heater model tuning instead.' }
  },
  { code: 'M304', name: 'Set Bed PID', category: 'PID & Advanced',
    description: 'Set PID parameters for the heated bed. Same concept as M301 but for the bed heater. Bed PID values are typically very different from hotend values because beds are much larger and slower.',
    params: [
      { letter: 'P', name: 'Proportional gain (Kp). Bed values are usually much higher than hotend (100-400)', example: '70.3' },
      { letter: 'I', name: 'Integral gain (Ki)', example: '1.6' },
      { letter: 'D', name: 'Derivative gain (Kd)', example: '350.0' },
    ],
    example: '; Apply bed PID values from M303 autotune:\nM304 P70.3 I1.6 D350.0\nM500 ; Save to EEPROM',
    template: 'M304 P__ I__ D__',
    firmware: { bambu: 'Not user-configurable on Bambu Lab.', klipper: 'PID values are set in printer.cfg under [heater_bed] section.', marlin: null, reprap: 'Use M307 for heater model tuning instead.' }
  },
];

let currentFirmware = 'bambu';

function onFirmwareChange(fw) {
  currentFirmware = fw;
  const profile = FIRMWARE[fw];

  // Update pause radio buttons (main pause tab)
  renderRadioGroup('pauseTypeGroup', 'pauseType', profile.pause);
  document.getElementById('pauseHint').textContent = profile.pauseHint;

  // Update insert pause radio buttons
  renderRadioGroup('insertPauseTypeGroup', 'insertPauseType', profile.pause);

  // Update filament command dropdown
  const filamentCmd = document.getElementById('filamentCmd');
  filamentCmd.innerHTML = profile.filament.map(f =>
    `<option value="${f.value}"${f.default ? ' selected' : ''}>${f.label}</option>`
  ).join('');
  document.getElementById('filamentHint').textContent = profile.filamentHint;

  // Show/hide AMS slot selector
  document.getElementById('filamentSlotGroup').style.display = profile.hasAMS ? '' : 'none';

  // Update eject hint
  document.getElementById('ejectHint').textContent = profile.ejectHint;

  // Update reference tab if rendered
  if (document.getElementById('refContent').children.length > 0) renderReference();
}

function renderRadioGroup(containerId, radioName, options) {
  const container = document.getElementById(containerId);
  container.innerHTML = options.map((opt, i) => {
    const id = `${radioName}_${i}`;
    return `<div class="radio-opt"><input type="radio" name="${radioName}" id="${id}" value="${opt.value}"${opt.default ? ' checked' : ''}><label for="${id}">${opt.label}</label></div>`;
  }).join('');
}

// ===== APP STATE =====
const parser = new GcodeParser();
const modifier = new GcodeModifier();
const holeDetector = new HoleDetector();
const insertManager = new InsertManager();
const undoStack = new UndoStack();
let selectedLayer = null;
let holeDetectMode = false;
let measureMode = false;
let measurePoints = [];

function toggleMeasureMode() {
  measureMode = !measureMode;
  measurePoints = [];
  document.getElementById('measureToggle').classList.toggle('active', measureMode);
  document.getElementById('viewerCanvas').style.cursor = measureMode ? 'crosshair' : '';
  if (currentView === 'visual') viewer.render(viewer.currentLayer);
}


// Initialize firmware UI
onFirmwareChange('bambu');

// ===== FILE HANDLING =====
const dropZone = document.getElementById('dropZone');
const fileInput = document.getElementById('fileInput');

dropZone.addEventListener('dragover', e => { e.preventDefault(); dropZone.classList.add('dragover'); });
dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
dropZone.addEventListener('drop', e => {
  e.preventDefault();
  dropZone.classList.remove('dragover');
  const file = e.dataTransfer.files[0];
  if (file) loadFile(file);
});
fileInput.addEventListener('change', e => { if (e.target.files[0]) loadFile(e.target.files[0]); });

// ===== ONBOARDING HINTS =====
const onboardState = JSON.parse(localStorage.getItem('gcode_onboard') || '{}');

function showOnboardHint(key, targetId, text) {
  if (onboardState[key]) return;
  const target = document.getElementById(targetId);
  if (!target) return;
  const hint = document.createElement('div');
  hint.className = 'onboard-hint below';
  hint.textContent = text;
  const dismiss = () => {
    hint.style.transition = 'opacity .3s';
    hint.style.opacity = '0';
    setTimeout(() => hint.remove(), 300);
    onboardState[key] = true;
    localStorage.setItem('gcode_onboard', JSON.stringify(onboardState));
  };
  hint.onclick = dismiss;
  target.style.position = 'relative';
  target.appendChild(hint);
  setTimeout(dismiss, 5000);
}

if (!onboardState.dropzone) {
  setTimeout(() => showOnboardHint('dropzone', 'dropZone', 'Drop a .gcode or .bgcode file here to get started'), 500);
}

// ===== BGCODE DECODER =====

// CRC32 lookup table and function
const crc32Table = (() => {
  const t = new Uint32Array(256);
  for (let i = 0; i < 256; i++) {
    let c = i;
    for (let j = 0; j < 8; j++) c = (c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1);
    t[i] = c;
  }
  return t;
})();
function crc32(buf) {
  let c = 0xFFFFFFFF;
  for (let i = 0; i < buf.length; i++) c = crc32Table[(c ^ buf[i]) & 0xFF] ^ (c >>> 8);
  return (c ^ 0xFFFFFFFF) >>> 0;
}

// Heatshrink decoder
function heatshrinkDecode(input, windowBits, lookaheadBits, outputSize) {
  const windowSize = 1 << windowBits;
  const lookaheadSize = 1 << lookaheadBits;
  const indexBits = windowBits;
  const backrefCountBits = lookaheadBits;
  const ringBuf = new Uint8Array(windowSize);
  const output = new Uint8Array(outputSize);
  let ringPos = 0, outPos = 0;

  // Bit reader
  let bitPos = 0, bytePos = 0;
  function bitsAvail() { return (input.length - bytePos) * 8 - bitPos; }
  function readBits(count) {
    let val = 0;
    for (let i = 0; i < count; i++) {
      if (bytePos >= input.length) return -1;
      val = (val << 1) | ((input[bytePos] >> (7 - bitPos)) & 1);
      bitPos++;
      if (bitPos === 8) { bitPos = 0; bytePos++; }
    }
    return val;
  }

  while (outPos < outputSize) {
    if (bitsAvail() < 1) break;
    const tag = readBits(1);
    if (tag === 1) {
      // Literal byte
      if (bitsAvail() < 8) break;
      const byte = readBits(8);
      ringBuf[ringPos & (windowSize - 1)] = byte;
      ringPos++;
      output[outPos++] = byte;
    } else {
      // Backref
      if (bitsAvail() < indexBits + backrefCountBits) break;
      const index = readBits(indexBits) + 1;
      const count = readBits(backrefCountBits) + 1;
      for (let i = 0; i < count; i++) {
        const byte = ringBuf[(ringPos - index) & (windowSize - 1)];
        ringBuf[ringPos & (windowSize - 1)] = byte;
        ringPos++;
        output[outPos++] = byte;
        if (outPos >= outputSize) break;
      }
    }
  }
  return output;
}

// Deflate decoder (browser-native)
async function deflateDecode(input, outputSize) {
  const ds = new DecompressionStream('deflate-raw');
  const writer = ds.writable.getWriter();
  const reader = ds.readable.getReader();
  const chunks = [];
  let totalLen = 0;
  const readAll = (async () => {
    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      chunks.push(value);
      totalLen += value.length;
    }
  })();
  writer.write(input);
  writer.close();
  await readAll;
  const result = new Uint8Array(totalLen);
  let off = 0;
  for (const c of chunks) { result.set(c, off); off += c.length; }
  return result;
}

// MeatPack decoder (matches libbgcode unbinarize)
function meatpackDecode(input) {
  const CMD_SIGNAL = 0xFF;
  const CMD_ENABLE  = 0xFB;  // EnablePacking
  const CMD_DISABLE = 0xFA;  // DisablePacking
  const CMD_NOSPACE_ON  = 0xF7;
  const CMD_NOSPACE_OFF = 0xF6;
  const CMD_RESET   = 0xF9;
  const GLINE_PARAMS = new Set([88,89,90,69,70,73,74,82,83,71,80,87,72,67,65]); // X Y Z E F I J R S G P W H C A

  let packing = false, noSpaces = false;
  let cmdCount = 0, cmdActive = false;
  let fullCharQueue = 0, charBuf = 0;
  const output = [];
  let lastChar = 0, addSpace = false;

  function getChar(nibble) {
    if (nibble <= 9) return 0x30 + nibble; // '0'-'9'
    if (nibble === 0xA) return 0x2E; // '.'
    if (nibble === 0xB) return noSpaces ? 0x45 : 0x20; // 'E' or ' '
    if (nibble === 0xC) return 0x0A; // '\n'
    if (nibble === 0xD) return 0x47; // 'G'
    if (nibble === 0xE) return 0x58; // 'X'
    return 0; // 0xF = escape marker
  }

  function emit(ch) {
    // Suppress duplicate newlines
    if (ch === 0x0A && lastChar === 0x0A) return;
    // Insert spaces on G-lines between parameters
    if (ch === 0x47 && (output.length === 0 || lastChar === 0x0A)) {
      addSpace = true;
    } else if (ch === 0x0A) {
      addSpace = false;
    } else if (addSpace && lastChar !== 0x20 && GLINE_PARAMS.has(ch)) {
      output.push(0x20);
      lastChar = 0x20;
    }
    output.push(ch);
    lastChar = ch;
  }

  function handleCommand(c) {
    if (c === CMD_ENABLE)  packing = true;
    else if (c === CMD_DISABLE) packing = false;
    else if (c === CMD_NOSPACE_ON) noSpaces = true;
    else if (c === CMD_NOSPACE_OFF) noSpaces = false;
    else if (c === CMD_RESET) { packing = false; noSpaces = false; }
  }

  function handleRxChar(c) {
    if (packing) {
      if (fullCharQueue > 0) {
        emit(c);
        if (charBuf > 0) { emit(charBuf); charBuf = 0; }
        fullCharQueue--;
      } else {
        const lo = c & 0x0F;
        const hi = (c >> 4) & 0x0F;
        const loEsc = (lo === 0x0F);
        const hiEsc = (hi === 0x0F);
        if (loEsc) {
          fullCharQueue++;
          if (hiEsc) fullCharQueue++;
          else charBuf = getChar(hi);
        } else {
          const ch0 = getChar(lo);
          emit(ch0);
          if (ch0 !== 0x0A) { // If first char is newline, skip second
            if (hiEsc) fullCharQueue++;
            else emit(getChar(hi));
          }
        }
      }
    } else {
      emit(c); // passthrough
    }
  }

  for (let i = 0; i < input.length; i++) {
    const c = input[i];
    if (c === CMD_SIGNAL) {
      if (cmdCount > 0) { cmdActive = true; cmdCount = 0; }
      else cmdCount++;
    } else {
      if (cmdActive) { handleCommand(c); cmdActive = false; }
      else {
        if (cmdCount > 0) { handleRxChar(CMD_SIGNAL); cmdCount = 0; }
        handleRxChar(c);
      }
    }
  }
  return new Uint8Array(output);
}

// Block parser and orchestrator
async function decodeBgcode(arrayBuffer) {
  const view = new DataView(arrayBuffer);
  const bytes = new Uint8Array(arrayBuffer);

  // File header (10 bytes)
  const magic = String.fromCharCode(bytes[0], bytes[1], bytes[2], bytes[3]);
  if (magic !== 'GCDE') throw new Error('Not a valid bgcode file (bad magic)');
  const version = view.getUint32(4, true);
  const checksumType = view.getUint16(8, true); // 0=None, 1=CRC32

  const progressEl = document.getElementById('parseProgress');
  const barEl = document.getElementById('parseBar');
  const labelEl = document.getElementById('parseLabel');
  progressEl.style.display = '';
  labelEl.textContent = 'Decoding binary G-code...';
  barEl.style.width = '0%';

  const gcodeChunks = [];
  let offset = 10;
  let blockIndex = 0;
  const fileSize = arrayBuffer.byteLength;

  while (offset < fileSize - 4) {
    if (offset + 8 > fileSize) break;
    const blockStart = offset;

    // Block header
    const blockType = view.getUint16(offset, true);
    const compression = view.getUint16(offset + 2, true);
    const uncompressedSize = view.getUint32(offset + 4, true);
    offset += 8;

    let compressedSize = uncompressedSize;
    if (compression !== 0) {
      compressedSize = view.getUint32(offset, true);
      offset += 4;
    }

    // Block params (Thumbnail=6 bytes, others=2 bytes)
    let encoding = 0;
    if (blockType === 5) { // Thumbnail
      offset += 6; // format + width + height
    } else {
      encoding = view.getUint16(offset, true);
      offset += 2;
    }

    const dataSize = compression !== 0 ? compressedSize : uncompressedSize;
    const blockData = bytes.subarray(offset, offset + dataSize);
    offset += dataSize;

    // CRC32 verification (covers header + params + data)
    if (checksumType === 1) {
      const storedCrc = view.getUint32(offset, true);
      offset += 4;
      if (blockType === 1) {
        const computedCrc = crc32(bytes.subarray(blockStart, offset - 4));
        if (computedCrc !== storedCrc) {
          console.warn(`CRC32 mismatch in GCode block ${blockIndex}: expected ${storedCrc.toString(16)}, got ${computedCrc.toString(16)}`);
        }
      }
    }

    // Only process GCode blocks (type 1)
    if (blockType !== 1) { blockIndex++; continue; }

    // Decompress
    let decompressed;
    if (compression === 0) {
      decompressed = blockData;
    } else if (compression === 1) { // Deflate
      decompressed = await deflateDecode(blockData, uncompressedSize);
    } else if (compression === 2) { // Heatshrink 11,4
      decompressed = heatshrinkDecode(blockData, 11, 4, uncompressedSize);
    } else if (compression === 3) { // Heatshrink 12,4
      decompressed = heatshrinkDecode(blockData, 12, 4, uncompressedSize);
    } else {
      throw new Error('Unknown compression type: ' + compression);
    }

    // Decode MeatPack
    let decoded;
    if (encoding === 0) {
      decoded = decompressed;
    } else if (encoding === 1 || encoding === 2) { // MeatPack / MeatPackComments
      decoded = meatpackDecode(decompressed);
    } else {
      throw new Error('Unknown encoding type: ' + encoding);
    }

    gcodeChunks.push(decoded);
    blockIndex++;

    // Update progress
    const pct = Math.min(offset / fileSize, 1);
    barEl.style.width = (pct * 100).toFixed(0) + '%';
    labelEl.textContent = `Decoding binary G-code... ${(pct * 100).toFixed(0)}%`;
    // Yield to UI thread periodically
    if (blockIndex % 4 === 0) await new Promise(r => setTimeout(r, 0));
  }

  // Concatenate all decoded chunks into a single string
  const totalLen = gcodeChunks.reduce((s, c) => s + c.length, 0);
  const merged = new Uint8Array(totalLen);
  let pos = 0;
  for (const chunk of gcodeChunks) { merged.set(chunk, pos); pos += chunk.length; }

  return new TextDecoder().decode(merged);
}

function loadFile(file) {
  const isBgcode = file.name.toLowerCase().endsWith('.bgcode');
  const reader = new FileReader();
  reader.onload = async (e) => {
    let text;
    if (isBgcode) {
      try {
        text = await decodeBgcode(e.target.result);
      } catch (err) {
        document.getElementById('parseProgress').style.display = 'none';
        document.getElementById('gcodePreview').innerHTML =
          `<div class="empty-state"><p style="color:var(--red)">Failed to decode bgcode file: ${err.message}</p></div>`;
        return;
      }
    } else {
      text = e.target.result;
    }

    const progressEl = document.getElementById('parseProgress');
    const barEl = document.getElementById('parseBar');
    const labelEl = document.getElementById('parseLabel');
    const lineCount = (text.match(/\n/g) || []).length;

    if (lineCount > 50000) {
      progressEl.style.display = '';
      labelEl.textContent = 'Parsing...';
      barEl.style.width = '0%';
    }

    await parser.parseAsync(text, file.name, pct => {
      barEl.style.width = (pct * 100).toFixed(0) + '%';
      labelEl.textContent = `Parsing... ${(pct * 100).toFixed(0)}%`;
    });

    progressEl.style.display = 'none';

    if (parser.layers.length === 0) {
      document.getElementById('gcodePreview').innerHTML =
        '<div class="empty-state"><p style="color:var(--red)">No layers detected in this file. It may not be a valid G-code file, or the slicer format is not yet supported.</p></div>';
      document.getElementById('parseProgress').style.display = 'none';
      return;
    }
    if (parser.skippedLines > 0) {
      showToast(parser.skippedLines + ' lines skipped during parsing', 'warning');
    }

    holeDetector.clearCache();
    viewer.clearBuffers();
    insertManager.clear();
    modifier.modifications = [];
    undoStack.push(modifier.modifications);
    holeDetectMode = false;
    document.getElementById('holeDetectToggle').classList.remove('active');
    document.getElementById('viewerCanvas').classList.remove('hole-mode');

    // Update UI
    document.getElementById('fileName').textContent = file.name;
    const slicerName = parser.slicerType !== 'unknown' ? ` · ${parser.slicerType}` : '';
    document.getElementById('fileMeta').textContent =
      `${parser.layers.length} layers  ·  ${parser.lines.length.toLocaleString()} lines${slicerName}`;
    document.getElementById('fileInfo').style.display = 'inline';
    document.getElementById('exportBtn').style.display = 'inline-flex';
    dropZone.innerHTML = `<svg width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4M17 8l-5-5-5 5M12 3v12"/></svg><span>Replace file</span>`;

    renderLayerList();
    // Setup viewer
    viewer.resize();
    viewer.fitBounds();
    updateSlider();
    if (parser.layers.length > 0) selectLayer(parser.layers[0].number);
    else renderFullPreview();

    showOnboardHint('visual', 'viewVisualBtn', 'Try the 3D Visual view');
  };
  if (isBgcode) reader.readAsArrayBuffer(file);
  else reader.readAsText(file);
}

// ===== LAYER LIST =====
function getModdedLayers() {
  const moddedLayers = new Set(modifier.modifications.filter(m => m.layer !== Infinity && m.layer !== 'end' && m.type !== 'zoffset').map(m => m.layer));
  for (const mod of modifier.modifications.filter(m => m.type === 'zoffset')) {
    for (const layer of parser.layers) {
      if (layer.number >= mod.layer && (mod.endLayer == null || layer.number <= mod.endLayer)) {
        moddedLayers.add(layer.number);
      }
    }
  }
  return moddedLayers;
}

function renderLayerList() {
  const container = document.getElementById('layerList');
  const moddedLayers = getModdedLayers();

  if (parser.layers.length === 0) {
    container.innerHTML = '<div class="empty-state"><p>No layers detected in this file</p></div>';
    return;
  }

  let html = '';
  for (const layer of parser.layers) {
    const active = selectedLayer === layer.number ? ' active' : '';
    const hasMod = moddedLayers.has(layer.number);
    html += `<div class="layer-item${active}" data-layer="${layer.number}" onclick="selectLayer(${layer.number})">
      ${hasMod ? '<div class="layer-mod-badge"></div>' : ''}
      <span class="layer-num">${layer.number}</span>
      <span class="layer-z">${layer.zHeight !== null ? 'Z' + layer.zHeight.toFixed(2) : ''}</span>
      <span class="layer-lines">${layer.lineCount} ln</span>
    </div>`;
  }
  container.innerHTML = html;
}

function filterLayers(query) {
  const items = document.querySelectorAll('.layer-item');
  const q = query.trim().toLowerCase();
  items.forEach(item => {
    const text = item.textContent.toLowerCase();
    item.style.display = (!q || text.includes(q)) ? '' : 'none';
  });
}

function selectLayer(num) {
  selectedLayer = num;
  renderLayerList();
  renderPreview(num);
  updateSlider();

  // Update visual viewer if active
  if (currentView === 'visual') {
    viewer.maxVisibleLayer = num;
    viewer.render(num);
    updateViewerOverlay(num);
  }

  // Fill layer number into active tab's layer input
  const activeTab = document.querySelector('.tab.active')?.dataset.tab;
  if (activeTab === 'pause') document.getElementById('pauseLayer').value = num;
  else if (activeTab === 'filament') document.getElementById('filamentLayer').value = num;
  else if (activeTab === 'zoffset') document.getElementById('zoffsetLayer').value = num;
  else if (activeTab === 'recovery') { document.getElementById('recoveryLayer').value = num; syncRecoveryFromLayer(); }

  // Update hole list if holes were detected
  if (holeDetector.scannedHoles.length > 0 || holeDetector.holes.has(num)) {
    renderHoleList();
  }
}

function jumpToLayer(num) {
  const layer = parser.getLayerByNumber(num);
  if (layer) selectLayer(num);
}

// ===== PREVIEW =====
function renderPreview(layerNum) {
  const container = document.getElementById('gcodePreview');
  const previewEmpty = document.getElementById('previewEmpty');
  if (previewEmpty) previewEmpty.remove();

  const layer = parser.getLayerByNumber(layerNum);
  if (!layer) return;

  const contextBefore = 5;
  const contextAfter = 10;
  const startLine = Math.max(0, layer.startLine - contextBefore);
  const endLine = Math.min(parser.lines.length - 1, layer.endLine + contextAfter);

  // Find modification lines for this layer
  const modLayers = new Set(modifier.modifications.filter(m => {
    if (m.type === 'zoffset') return layerNum >= m.layer && (m.endLayer == null || layerNum <= m.endLayer);
    return m.layer === layerNum;
  }).map(m => m.id));

  let html = '<table class="code-table"><tbody>';
  for (let i = startLine; i <= endLine; i++) {
    const raw = parser.lines[i];
    const isLayerStart = raw.trim().match(/^;LAYER:\d+/i);
    const isHighlight = i >= layer.startLine && i <= layer.endLine;
    const classes = [];
    if (isLayerStart) classes.push('layer-start');
    if (isHighlight) classes.push('highlight');

    html += `<tr class="${classes.join(' ')}"><td class="ln">${i + 1}</td><td>${syntaxHighlight(raw)}</td></tr>`;
  }

  // Show modification preview snippets
  if (modLayers.size > 0) {
    html += '<tr class="layer-start"><td class="ln" style="color:var(--orange)">+</td><td style="color:var(--orange);font-weight:600">; ── Modifications to be inserted ──</td></tr>';
    for (const mod of modifier.modifications.filter(m => {
      if (m.type === 'zoffset') return layerNum >= m.layer && (m.endLayer == null || layerNum <= m.endLayer);
      return m.layer === layerNum;
    })) {
      const snippet = modifier.getSnippet(mod);
      for (const line of snippet) {
        html += `<tr class="mod-line"><td class="ln">+</td><td>${syntaxHighlight(line)}</td></tr>`;
      }
    }
  }

  html += '</tbody></table>';
  container.innerHTML = html;

  document.getElementById('previewInfo').textContent =
    `Layer ${layer.number}  ·  Z${layer.zHeight?.toFixed(2) || '?'}mm  ·  Lines ${layer.startLine + 1}–${layer.endLine + 1}`;
}

function renderFullPreview() {
  const container = document.getElementById('gcodePreview');
  const previewEmpty = document.getElementById('previewEmpty');
  if (previewEmpty) previewEmpty.remove();

  // Show first 200 lines (Bambu headers can be very long)
  const end = Math.min(200, parser.lines.length);
  let html = '<table class="code-table"><tbody>';
  for (let i = 0; i < end; i++) {
    html += `<tr><td class="ln">${i + 1}</td><td>${syntaxHighlight(parser.lines[i])}</td></tr>`;
  }
  if (parser.lines.length > 200) {
    html += `<tr><td class="ln">...</td><td style="color:var(--text-dim)">... ${(parser.lines.length - 200).toLocaleString()} more lines ...</td></tr>`;
  }
  html += '</tbody></table>';
  container.innerHTML = html;
}

function syntaxHighlight(line) {
  if (!line) return '';
  let escaped = line.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');

  // Comments
  if (escaped.trim().startsWith(';')) {
    return `<span class="syn-comment">${escaped}</span>`;
  }

  // Inline comments
  const commentIdx = escaped.indexOf(';');
  let main = commentIdx > -1 ? escaped.substring(0, commentIdx) : escaped;
  let comment = commentIdx > -1 ? `<span class="syn-comment">${escaped.substring(commentIdx)}</span>` : '';

  // G commands
  main = main.replace(/\b(G\d+(\.\d+)?)/g, '<span class="syn-g">$1</span>');
  // M commands
  main = main.replace(/\b(M\d+)/g, '<span class="syn-m">$1</span>');
  // Parameters (letters followed by numbers)
  main = main.replace(/\b([XYZEFIJKRSTPQAB])([-\d.]+)/g, '<span class="syn-param">$1</span><span class="syn-value">$2</span>');

  return main + comment;
}

// ===== TOAST NOTIFICATIONS =====
function showToast(message, type = 'success', duration = 4000) {
  const container = document.getElementById('toastContainer');
  const toast = document.createElement('div');
  toast.className = `toast ${type}`;
  toast.innerHTML = `<span>${message}</span><button class="toast-close" onclick="this.parentElement.remove()">&times;</button>`;
  container.appendChild(toast);
  if (duration > 0) setTimeout(() => toast.remove(), duration);
}

// ===== TAB SWITCHING =====
function switchTab(tabName) {
  document.querySelectorAll('.tab').forEach(t => t.classList.toggle('active', t.dataset.tab === tabName));
  document.querySelectorAll('.tab-content').forEach(tc => tc.classList.toggle('active', tc.id === 'tab-' + tabName));
  if (tabName === 'reference' && document.getElementById('refContent').children.length === 0) {
    renderReference();
  }
}

// ===== REFERENCE TAB =====
function renderReference() {
  const fw = currentFirmware;
  const fwName = FIRMWARE[fw].name;
  document.getElementById('refFirmwareBadge').innerHTML = 'Showing notes for: <span>' + fwName + '</span>';

  const categories = [];
  const catMap = {};
  GCODE_REFERENCE.forEach(cmd => {
    if (!catMap[cmd.category]) {
      catMap[cmd.category] = [];
      categories.push(cmd.category);
    }
    catMap[cmd.category].push(cmd);
  });

  let html = '';
  categories.forEach(cat => {
    html += '<div class="ref-category" data-category="' + cat + '">';
    html += '<div class="ref-category-header" onclick="this.parentElement.classList.toggle(\'collapsed\')">' + cat + '</div>';
    html += '<div class="ref-category-cards">';
    catMap[cat].forEach(cmd => {
      const fwNote = cmd.firmware[fw];
      html += '<div class="ref-card" data-search="' + (cmd.code + ' ' + cmd.name + ' ' + cmd.description).toLowerCase().replace(/"/g, '&quot;') + '">';
      html += '<div class="ref-card-head"><span class="ref-card-code">' + cmd.code + '</span><span class="ref-card-name">' + cmd.name + '</span>';
      html += '<button class="ref-card-insert" onclick="insertRefCommand(\'' + cmd.code.replace(/'/g, "\\'") + '\');event.stopPropagation()">Insert</button></div>';
      html += '<div class="ref-card-desc">' + cmd.description + '</div>';
      if (cmd.params.length > 0) {
        html += '<table class="ref-card-params"><tr><th>Param</th><th>Description</th><th>Example</th></tr>';
        cmd.params.forEach(p => {
          html += '<tr><td>' + p.letter + '</td><td>' + p.name + '</td><td>' + p.example + '</td></tr>';
        });
        html += '</table>';
      }
      html += '<div class="ref-card-example">' + cmd.example.replace(/\n/g, '<br>') + '</div>';
      if (fwNote) {
        html += '<div class="ref-card-firmware">' + fwName + ': ' + fwNote + '</div>';
      }
      html += '</div>';
    });
    html += '</div></div>';
  });

  document.getElementById('refContent').innerHTML = html;
}

function filterReferenceCards() {
  const query = document.getElementById('refSearch').value.toLowerCase().trim();
  const categories = document.querySelectorAll('#refContent .ref-category');
  let anyVisible = false;

  categories.forEach(cat => {
    const cards = cat.querySelectorAll('.ref-card');
    let catVisible = false;
    cards.forEach(card => {
      const match = !query || card.dataset.search.includes(query);
      card.style.display = match ? '' : 'none';
      if (match) catVisible = true;
    });
    cat.style.display = catVisible ? '' : 'none';
    if (catVisible) anyVisible = true;
  });

  let noRes = document.getElementById('refNoResults');
  if (!anyVisible) {
    if (!noRes) {
      noRes = document.createElement('div');
      noRes.id = 'refNoResults';
      noRes.className = 'ref-no-results';
      noRes.textContent = 'No commands found matching your search.';
      document.getElementById('refContent').appendChild(noRes);
    }
    noRes.style.display = '';
  } else if (noRes) {
    noRes.style.display = 'none';
  }
}

function insertRefCommand(code) {
  const cmd = GCODE_REFERENCE.find(c => c.code === code);
  if (!cmd) return;
  switchTab('custom');
  const textarea = document.getElementById('customGcode');
  textarea.value = cmd.template;
  const layerInput = document.getElementById('customLayer');
  if (selectedLayer != null && layerInput.value === '') {
    layerInput.value = selectedLayer;
  }
  showToast(cmd.code + ' inserted into Custom G-code tab', 'success');
}

// ===== ADD MODIFICATIONS =====
function addPause() {
  const layer = parseInt(document.getElementById('pauseLayer').value);
  if (isNaN(layer)) { showToast('Please enter a valid layer number.', 'error'); return; }
  if (!parser.getLayerByNumber(layer)) { showToast(`Layer ${layer} not found in the file.`, 'error'); return; }

  const msg = document.getElementById('pauseMsg').value;
  const pauseType = document.querySelector('input[name="pauseType"]:checked').value;
  const moveHead = document.getElementById('pauseMoveHead').checked;

  modifier.addPause(layer, msg, pauseType, moveHead);
  refreshAfterMod();
  showToast('Pause added at layer ' + layer, 'success');
}

function addFilamentChange() {
  const layer = parseInt(document.getElementById('filamentLayer').value);
  if (isNaN(layer)) { showToast('Please enter a valid layer number.', 'error'); return; }
  if (!parser.getLayerByNumber(layer)) { showToast(`Layer ${layer} not found in the file.`, 'error'); return; }

  const slot = document.getElementById('filamentSlot').value;
  const cmd = document.getElementById('filamentCmd').value;

  modifier.addFilament(layer, slot, cmd);
  refreshAfterMod();
  showToast('Filament change added at layer ' + layer, 'success');
}

function addEject() {
  const config = {
    bedY: parseInt(document.getElementById('ejectY').value) || 220,
    headZ: parseInt(document.getElementById('ejectZ').value) || 10,
    feedRate: parseInt(document.getElementById('ejectFeed').value) || 6000,
    heatersOff: document.getElementById('ejectHeatersOff').checked,
    homeZ: document.getElementById('ejectHomeZ').checked,
    loop: document.getElementById('ejectLoop').checked,
  };
  modifier.addEject(config);
  refreshAfterMod();
  showToast('Eject sequence added', 'success');
}

function syncRecoveryFromLayer() {
  const layerNum = parseInt(document.getElementById('recoveryLayer').value);
  if (isNaN(layerNum) || !parser.layers.length) return;
  const layer = parser.getLayerByNumber(layerNum);
  if (layer && layer.zHeight != null) {
    document.getElementById('recoveryHeight').value = layer.zHeight.toFixed(2);
  }
}

function syncRecoveryFromHeight() {
  const height = parseFloat(document.getElementById('recoveryHeight').value);
  if (isNaN(height) || !parser.layers.length) return;
  // Find the last layer at or below the given height
  let best = null;
  for (const layer of parser.layers) {
    if (layer.zHeight != null && layer.zHeight <= height + 0.001) {
      best = layer;
    }
  }
  if (best) {
    document.getElementById('recoveryLayer').value = best.number;
  }
}

function addRecovery() {
  const layer = parseInt(document.getElementById('recoveryLayer').value);
  if (isNaN(layer)) { showToast('Please enter a layer number or height.', 'error'); return; }
  if (layer === 0) { showToast('Layer 0 is already the first layer — no recovery needed.', 'warning'); return; }
  if (!parser.getLayerByNumber(layer)) { showToast(`Layer ${layer} not found in the file.`, 'error'); return; }
  const lastLayer = parser.layers[parser.layers.length - 1];
  if (lastLayer && layer === lastLayer.number) {
    showToast('Warning: recovery print will only contain the final layer.', 'warning');
  }
  modifier.addRecovery(layer);
  refreshAfterMod();
  showToast(`Recovery added: resume from layer ${layer}`, 'success');
}

function addZOffset() {
  const layer = parseInt(document.getElementById('zoffsetLayer').value);
  if (isNaN(layer)) { showToast('Please enter a valid start layer number.', 'error'); return; }
  if (!parser.getLayerByNumber(layer)) { showToast(`Layer ${layer} not found in the file.`, 'error'); return; }

  const endLayerInput = document.getElementById('zoffsetEndLayer').value.trim();
  let endLayer = null;
  if (endLayerInput !== '') {
    endLayer = parseInt(endLayerInput);
    if (isNaN(endLayer)) { showToast('Please enter a valid end layer number or leave blank.', 'error'); return; }
    if (!parser.getLayerByNumber(endLayer)) { showToast(`Layer ${endLayer} not found in the file.`, 'error'); return; }
    if (endLayer < layer) { showToast('End layer must be >= start layer.', 'error'); return; }
  }

  const offset = parseFloat(document.getElementById('zoffsetValue').value);
  if (isNaN(offset) || offset === 0) { showToast('Please enter a non-zero Z-offset value.', 'error'); return; }

  const note = document.getElementById('zoffsetNote').value.trim();

  modifier.addZOffset(layer, endLayer, offset, note);
  refreshAfterMod();
  showToast('Z-offset added at layer ' + layer, 'success');
}

function addCustom() {
  let layerInput = document.getElementById('customLayer').value.trim();
  const gcode = document.getElementById('customGcode').value.trim();
  if (!gcode) { showToast('Please enter some G-code.', 'error'); return; }

  let layer;
  if (layerInput.toLowerCase() === 'end') {
    layer = 'end';
  } else {
    layer = parseInt(layerInput);
    if (isNaN(layer)) { showToast('Please enter a valid layer number or "end".', 'error'); return; }
    if (!parser.getLayerByNumber(layer)) { showToast(`Layer ${layer} not found in the file.`, 'error'); return; }
  }

  modifier.addCustom(layer, gcode);
  refreshAfterMod();
  showToast('Custom G-code added at layer ' + layer, 'success');
}

function refreshAfterMod() {
  undoStack.push(modifier.modifications);
  renderModsList();
  renderLayerList();
  updateSliderTicks();
  if (selectedLayer !== null) {
    renderPreview(selectedLayer);
    if (currentView === 'visual') {
      viewer.maxVisibleLayer = selectedLayer;
      viewer.render(selectedLayer);
      updateViewerOverlay(selectedLayer);
    }
  }
  if (modifier.modifications.length === 1) {
    showOnboardHint('export', 'exportBtn', 'Export to save your changes');
  }
}

// ===== MODIFICATIONS LIST =====
function renderModsList() {
  const container = document.getElementById('modsList');
  const noMods = document.getElementById('noMods');
  const count = modifier.modifications.length;
  document.getElementById('modsCount').textContent = count;

  if (count === 0) {
    container.innerHTML = '<div class="no-mods" id="noMods">No modifications added yet</div>';
    return;
  }

  let html = '';
  for (const mod of modifier.modifications) {
    const badge = mod.type;
    let desc = '';
    switch (mod.type) {
      case 'pause':
        desc = `Layer ${mod.layer}${mod.message ? ' – ' + mod.message : ''}`;
        break;
      case 'filament':
        desc = mod.command === 'M1020' ? `Layer ${mod.layer} → Slot ${mod.slot + 1} (${mod.command})` : `Layer ${mod.layer} (${mod.command})`;
        break;
      case 'eject':
        desc = `End of file${mod.loop ? ' (loop)' : ''}`;
        break;
      case 'zoffset': {
        const sign = mod.offset >= 0 ? '+' : '';
        const range = mod.endLayer != null ? `L${mod.layer}–${mod.endLayer}` : `L${mod.layer}+`;
        desc = `${range}: ${sign}${mod.offset}mm${mod.note ? ' – ' + mod.note : ''}`;
        break;
      }
      case 'custom':
        desc = mod.layer === 'end' ? 'End of file' : `Layer ${mod.layer}`;
        break;
      case 'recovery':
        desc = `Resume from layer ${mod.resumeLayer}`;
        break;
    }

    html += `<div class="mod-item" data-id="${mod.id}" draggable="true"
  ondragstart="onModDragStart(event,'${mod.id}')"
  ondragover="onModDragOver(event)"
  ondrop="onModDrop(event,'${mod.id}')"
  ondragend="onModDragEnd()">
      <span class="mod-badge ${badge}">${badge}</span>
      <span class="mod-desc" title="${desc}">${desc}</span>
      <div class="mod-actions">
        <button class="mod-action delete" onclick="modifier.remove('${mod.id}');refreshAfterMod()" title="Delete">&times;</button>
      </div>
    </div>`;
  }
  container.innerHTML = html;
}


let dragModId = null;

function onModDragStart(e, modId) {
  dragModId = modId;
  e.dataTransfer.effectAllowed = 'move';
  e.target.style.opacity = '0.4';
}

function onModDragOver(e) {
  e.preventDefault();
  e.dataTransfer.dropEffect = 'move';
  const item = e.target.closest('.mod-item');
  document.querySelectorAll('.mod-item').forEach(el => el.style.borderTop = '');
  if (item) item.style.borderTop = '2px solid var(--accent)';
}

function onModDrop(e, targetId) {
  e.preventDefault();
  if (!dragModId || dragModId === targetId) return;

  const mods = modifier.modifications;
  const fromIdx = mods.findIndex(m => m.id === dragModId);
  const toIdx = mods.findIndex(m => m.id === targetId);
  if (fromIdx < 0 || toIdx < 0) return;

  const [moved] = mods.splice(fromIdx, 1);
  mods.splice(toIdx, 0, moved);

  refreshAfterMod();
}

function onModDragEnd() {
  dragModId = null;
  document.querySelectorAll('.mod-item').forEach(el => {
    el.style.opacity = '';
    el.style.borderTop = '';
  });
}

// ===== VIEW TOGGLE =====
let currentView = 'code';

function setView(view) {
  currentView = view;
  document.getElementById('viewCodeBtn').classList.toggle('active', view === 'code');
  document.getElementById('viewVisualBtn').classList.toggle('active', view === 'visual');
  document.getElementById('gcodePreview').classList.toggle('hidden', view === 'visual');
  document.getElementById('viewerWrap').classList.toggle('active', view === 'visual');
  if (view === 'visual' && selectedLayer !== null) {
    viewer.resize();
    viewer.fitBounds();
    viewer.maxVisibleLayer = selectedLayer;
    viewer.render(selectedLayer);
    updateViewerOverlay(selectedLayer);
  }
}

function onSliderChange(val) {
  // Map slider index to layer number
  if (parser.layers[val]) {
    selectLayer(parser.layers[val].number);
    document.getElementById('sliderLabel').textContent = `Layer ${parser.layers[val].number}`;
  }
}

function updateSlider() {
  const slider = document.getElementById('layerSlider');
  slider.max = Math.max(0, parser.layers.length - 1);
  const idx = parser.layers.findIndex(l => l.number === selectedLayer);
  if (idx >= 0) slider.value = idx;
  document.getElementById('sliderLabel').textContent = `Layer ${selectedLayer ?? 0}`;
  updateSliderTicks();
}

function updateSliderTicks() {
  const container = document.getElementById('sliderTicks');
  const moddedLayers = getModdedLayers();
  if (parser.layers.length === 0 || moddedLayers.size === 0) { container.innerHTML = ''; return; }
  let html = '';
  for (const mod of modifier.modifications) {
    if (mod.layer === Infinity || mod.layer === 'end') continue;
    const idx = parser.layers.findIndex(l => l.number === mod.layer);
    if (idx < 0) continue;
    const pct = (idx / Math.max(1, parser.layers.length - 1)) * 100;
    const color = mod.type === 'pause' ? 'var(--yellow)' : mod.type === 'filament' ? 'var(--purple)' : mod.type === 'zoffset' ? 'var(--orange)' : 'var(--accent)';
    html += `<div class="slider-tick" style="left:${pct}%;background:${color}"></div>`;
  }
  container.innerHTML = html;
}

function updateViewerOverlay(layerNum) {
  const overlay = document.getElementById('viewerOverlay');
  const layer = parser.getLayerByNumber(layerNum);
  if (!layer) { overlay.innerHTML = ''; return; }

  let html = `<div class="viewer-info">Layer ${layer.number} · Z${layer.zHeight?.toFixed(2) || '?'}mm · ${layer.lineCount} lines</div>`;

  // Show modification banners
  const mods = modifier.modifications.filter(m => {
    if (m.type === 'zoffset') return layerNum >= m.layer && (m.endLayer == null || layerNum <= m.endLayer);
    return m.layer === layerNum;
  });
  for (const mod of mods) {
    if (mod.type === 'pause') {
      html += `<div class="viewer-mod-banner pause">⏸ Pause at this layer${mod.message ? ': ' + mod.message : ''}</div>`;
    } else if (mod.type === 'filament') {
      html += `<div class="viewer-mod-banner filament">🔄 Filament change${mod.command === 'M1020' ? ' → Slot ' + (mod.slot + 1) : ''} (${mod.command})</div>`;
    } else if (mod.type === 'zoffset') {
      const sign = mod.offset >= 0 ? '+' : '';
      html += `<div class="viewer-mod-banner pause">↕ Z-Offset: ${sign}${mod.offset}mm${mod.note ? ' – ' + mod.note : ''}</div>`;
    } else if (mod.type === 'custom') {
      html += `<div class="viewer-mod-banner custom">⚙ Custom G-code inserted</div>`;
    } else if (mod.type === 'recovery') {
      html += `<div class="viewer-mod-banner recovery">Recovery: resume from layer ${mod.resumeLayer}</div>`;
    }
  }
  overlay.innerHTML = html;
}

// ===== GCODE VIEWER (old Canvas 2D removed — now using GcodeViewer3D) =====

class GcodeViewer3D {
  constructor(canvasId) {
    this.canvas = document.getElementById(canvasId);
    this.gl = this.canvas.getContext('webgl2', { preserveDrawingBuffer: true });
    if (!this.gl) {
      console.error('GcodeViewer3D: WebGL2 not supported');
      this._broken = true;
      return;
    }

    this.currentLayer = 0;
    this.maxVisibleLayer = 0;
    this.layerBuffers = new Map();
    this.modMarkers = []; // Modification marker geometry for overlay rendering

    // Camera state
    this.cam = {
      rotX: 0.6,
      rotZ: 0.4,
      panX: 0,
      panY: 0,
      zoom: 1.0,
      target: [0, 0, 0],
    };

    this._dragging = false;
    this._dragButton = -1;
    this._lastMouse = { x: 0, y: 0 };
    this._mouseMoved = false;
    // Set by resize() — must be called before first render
    this._w = 0;
    this._h = 0;

    this._initShaders();
    if (this._broken) return;
    this._setupInteraction();
  }

  // --- Shader source ---
  static VS = `#version 300 es
    uniform mat4 u_mvp;
    uniform float u_alphaOverride;
    in vec3 a_pos;
    in vec3 a_color;
    in float a_alpha;
    out vec3 v_color;
    out float v_alpha;
    void main() {
      gl_Position = u_mvp * vec4(a_pos, 1.0);
      v_color = a_color;
      v_alpha = u_alphaOverride > 0.0 ? u_alphaOverride : a_alpha;
    }
  `;

  static FS = `#version 300 es
    precision mediump float;
    in vec3 v_color;
    in float v_alpha;
    out vec4 fragColor;
    void main() {
      fragColor = vec4(v_color, v_alpha);
    }
  `;

  // Line shader for travel moves and grid
  static LINE_VS = `#version 300 es
    uniform mat4 u_mvp;
    in vec3 a_pos;
    in vec4 a_color;
    out vec4 v_color;
    void main() {
      gl_Position = u_mvp * vec4(a_pos, 1.0);
      v_color = a_color;
    }
  `;

  static LINE_FS = `#version 300 es
    precision mediump float;
    in vec4 v_color;
    out vec4 fragColor;
    void main() {
      fragColor = v_color;
    }
  `;

  // --- Matrix math (column-major Float32Array) ---
  static mat4Identity() {
    return new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]);
  }

  static mat4Multiply(a, b) {
    const r = new Float32Array(16);
    for (let i = 0; i < 4; i++)
      for (let j = 0; j < 4; j++) {
        r[j * 4 + i] = a[i] * b[j * 4] + a[4 + i] * b[j * 4 + 1] + a[8 + i] * b[j * 4 + 2] + a[12 + i] * b[j * 4 + 3];
      }
    return r;
  }

  static mat4Perspective(fov, aspect, near, far) {
    const f = 1 / Math.tan(fov / 2);
    const nf = 1 / (near - far);
    return new Float32Array([
      f / aspect, 0, 0, 0,
      0, f, 0, 0,
      0, 0, (far + near) * nf, -1,
      0, 0, 2 * far * near * nf, 0
    ]);
  }

  static mat4LookAt(eye, center, up) {
    let zx = eye[0] - center[0], zy = eye[1] - center[1], zz = eye[2] - center[2];
    let len = Math.hypot(zx, zy, zz); zx /= len; zy /= len; zz /= len;
    let xx = up[1] * zz - up[2] * zy, xy = up[2] * zx - up[0] * zz, xz = up[0] * zy - up[1] * zx;
    len = Math.hypot(xx, xy, xz); xx /= len; xy /= len; xz /= len;
    let yx = zy * xz - zz * xy, yy = zz * xx - zx * xz, yz = zx * xy - zy * xx;
    return new Float32Array([
      xx, yx, zx, 0, xy, yy, zy, 0, xz, yz, zz, 0,
      -(xx * eye[0] + xy * eye[1] + xz * eye[2]),
      -(yx * eye[0] + yy * eye[1] + yz * eye[2]),
      -(zx * eye[0] + zy * eye[1] + zz * eye[2]), 1
    ]);
  }

  _getMVP() {
    const b = parser.bounds;
    const cx = (b.minX + b.maxX) / 2;
    const cy = (b.minY + b.maxY) / 2;
    const maxLayer = parser.layers[parser.layers.length - 1];
    const maxZ = maxLayer ? (maxLayer.zHeight || 0) : 0;
    const cz = maxZ / 2;

    const dist = Math.max(b.maxX - b.minX, b.maxY - b.minY, maxZ || 50) * 1.5 / this.cam.zoom;

    const eyeX = cx + this.cam.panX + dist * Math.cos(this.cam.rotX) * Math.sin(this.cam.rotZ);
    const eyeY = cy + this.cam.panY + dist * Math.cos(this.cam.rotX) * Math.cos(this.cam.rotZ);
    const eyeZ = cz + dist * Math.sin(this.cam.rotX);

    const target = [cx + this.cam.panX, cy + this.cam.panY, cz];
    const aspect = this._w / (this._h || 1);
    const proj = GcodeViewer3D.mat4Perspective(Math.PI / 4, aspect, 0.1, dist * 10);
    const view = GcodeViewer3D.mat4LookAt([eyeX, eyeY, eyeZ], target, [0, 0, 1]);
    return GcodeViewer3D.mat4Multiply(proj, view);
  }

  _compileShader(src, type) {
    const gl = this.gl;
    const shader = gl.createShader(type);
    gl.shaderSource(shader, src);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      console.error('Shader compile error:', gl.getShaderInfoLog(shader));
      gl.deleteShader(shader);
      return null;
    }
    return shader;
  }

  _linkProgram(vs, fs) {
    const gl = this.gl;
    const prog = gl.createProgram();
    gl.attachShader(prog, vs);
    gl.attachShader(prog, fs);
    gl.linkProgram(prog);
    if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
      console.error('Program link error:', gl.getProgramInfoLog(prog));
      return null;
    }
    // Detach and delete intermediate shader objects to free GPU memory
    gl.detachShader(prog, vs);
    gl.detachShader(prog, fs);
    gl.deleteShader(vs);
    gl.deleteShader(fs);
    return prog;
  }

  // --- Type colors for extrusion rendering ---
  static TYPE_COLORS = {
    'WALL-OUTER': [0.376, 0.647, 0.980],
    'WALL-INNER': [0.576, 0.773, 0.992],
    'OUTER WALL': [0.376, 0.647, 0.980],
    'INNER WALL': [0.576, 0.773, 0.992],
    'FILL': [0.290, 0.867, 0.502],
    'SOLID': [0.290, 0.867, 0.502],
    'SPARSE': [0.290, 0.867, 0.502],
    'SOLID INFILL': [0.290, 0.867, 0.502],
    'SPARSE INFILL': [0.290, 0.867, 0.502],
    'INTERNAL SOLID INFILL': [0.290, 0.867, 0.502],
    'TOP': [0.133, 0.827, 0.933],
    'TOP SURFACE': [0.133, 0.827, 0.933],
    'BOTTOM': [0.133, 0.827, 0.933],
    'BOTTOM SURFACE': [0.133, 0.827, 0.933],
    'SUPPORT': [0.980, 0.800, 0.082],
    'SUPPORT-INTERFACE': [0.992, 0.910, 0.541],
    'OVERHANG': [0.984, 0.573, 0.235],
    'GAP INFILL': [0.984, 0.573, 0.235],
    'BRIDGE': [0.976, 0.451, 0.086],
    'SKIRT': [0.655, 0.545, 0.980],
    'BRIM': [0.655, 0.545, 0.980],
    'CUSTOM': [0.655, 0.545, 0.980],
    'DEFAULT': [0.878, 0.886, 0.910],
  };

  _getTypeColor(type) {
    const upper = type.toUpperCase();
    for (const [key, color] of Object.entries(GcodeViewer3D.TYPE_COLORS)) {
      if (upper.includes(key)) return color;
    }
    return GcodeViewer3D.TYPE_COLORS.DEFAULT;
  }

  _buildLayerGeometry(layerNum) {
    if (this._broken) return null;
    if (this.layerBuffers.has(layerNum)) return this.layerBuffers.get(layerNum);

    const gl = this.gl;
    const moves = parser.layerMoves[layerNum];
    if (!moves || moves.length === 0) {
      this.layerBuffers.set(layerNum, null);
      return null;
    }

    const layer = parser.getLayerByNumber(layerNum);
    const z = layer?.zHeight || 0;
    const halfW = 0.2; // half ribbon width in mm

    // Extrusion ribbons: x,y,z, r,g,b, alpha per vertex
    const ribbonVerts = [];
    // Travel lines: x,y,z, r,g,b,a per vertex
    const travelVerts = [];

    for (const move of moves) {
      if (move.extrude) {
        const color = this._getTypeColor(move.type);
        const dx = move.x2 - move.x1;
        const dy = move.y2 - move.y1;
        const len = Math.hypot(dx, dy);
        if (len < 0.001) continue;
        // Perpendicular offset for ribbon width
        const nx = -dy / len * halfW;
        const ny = dx / len * halfW;

        // Two triangles forming a ribbon
        const verts = [
          move.x1 + nx, move.y1 + ny, z,
          move.x1 - nx, move.y1 - ny, z,
          move.x2 + nx, move.y2 + ny, z,
          move.x2 + nx, move.y2 + ny, z,
          move.x1 - nx, move.y1 - ny, z,
          move.x2 - nx, move.y2 - ny, z,
        ];
        for (let i = 0; i < 6; i++) {
          ribbonVerts.push(
            verts[i * 3], verts[i * 3 + 1], verts[i * 3 + 2],
            color[0], color[1], color[2],
            1.0
          );
        }
      } else {
        // Travel move as a line
        travelVerts.push(
          move.x1, move.y1, z, 0.3, 0.3, 0.3, 0.3,
          move.x2, move.y2, z, 0.3, 0.3, 0.3, 0.3,
        );
      }
    }

    const result = { ribbonVao: null, ribbonCount: 0, travelVao: null, travelCount: 0 };

    if (ribbonVerts.length > 0) {
      const data = new Float32Array(ribbonVerts);
      const stride = 7 * 4; // 7 floats per vertex
      const vbo = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
      gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);

      const vao = gl.createVertexArray();
      gl.bindVertexArray(vao);
      gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
      gl.enableVertexAttribArray(this.a_pos);
      gl.vertexAttribPointer(this.a_pos, 3, gl.FLOAT, false, stride, 0);
      gl.enableVertexAttribArray(this.a_color);
      gl.vertexAttribPointer(this.a_color, 3, gl.FLOAT, false, stride, 12);
      gl.enableVertexAttribArray(this.a_alpha);
      gl.vertexAttribPointer(this.a_alpha, 1, gl.FLOAT, false, stride, 24);
      gl.bindVertexArray(null);

      result.ribbonVao = vao;
      result.ribbonCount = ribbonVerts.length / 7;
    }

    if (travelVerts.length > 0) {
      const data = new Float32Array(travelVerts);
      const stride = 7 * 4;
      const vbo = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
      gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);

      const vao = gl.createVertexArray();
      gl.bindVertexArray(vao);
      gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
      gl.enableVertexAttribArray(this.line_a_pos);
      gl.vertexAttribPointer(this.line_a_pos, 3, gl.FLOAT, false, stride, 0);
      gl.enableVertexAttribArray(this.line_a_color);
      gl.vertexAttribPointer(this.line_a_color, 4, gl.FLOAT, false, stride, 12);
      gl.bindVertexArray(null);

      result.travelVao = vao;
      result.travelCount = travelVerts.length / 7;
    }

    this.layerBuffers.set(layerNum, result);
    return result;
  }

  clearBuffers() {
    if (this._broken) return;
    const gl = this.gl;
    for (const [, buf] of this.layerBuffers) {
      if (!buf) continue;
      if (buf.ribbonVao) gl.deleteVertexArray(buf.ribbonVao);
      if (buf.travelVao) gl.deleteVertexArray(buf.travelVao);
    }
    this.layerBuffers.clear();
  }

  _initShaders() {
    const gl = this.gl;
    // Main ribbon shader
    const vs = this._compileShader(GcodeViewer3D.VS, gl.VERTEX_SHADER);
    const fs = this._compileShader(GcodeViewer3D.FS, gl.FRAGMENT_SHADER);
    if (!vs || !fs) { this._broken = true; return; }
    this.prog = this._linkProgram(vs, fs);
    if (!this.prog) { this._broken = true; return; }
    this.u_mvp = gl.getUniformLocation(this.prog, 'u_mvp');
    // u_alphaOverride: set > 0 to override per-vertex alpha, set <= 0 to use vertex alpha
    this.u_alphaOverride = gl.getUniformLocation(this.prog, 'u_alphaOverride');
    this.a_pos = gl.getAttribLocation(this.prog, 'a_pos');
    this.a_color = gl.getAttribLocation(this.prog, 'a_color');
    this.a_alpha = gl.getAttribLocation(this.prog, 'a_alpha');

    // Line shader (separate program for GL_LINES with vec4 color including alpha)
    const lvs = this._compileShader(GcodeViewer3D.LINE_VS, gl.VERTEX_SHADER);
    const lfs = this._compileShader(GcodeViewer3D.LINE_FS, gl.FRAGMENT_SHADER);
    if (!lvs || !lfs) { this._broken = true; return; }
    this.lineProg = this._linkProgram(lvs, lfs);
    if (!this.lineProg) { this._broken = true; return; }
    this.line_u_mvp = gl.getUniformLocation(this.lineProg, 'u_mvp');
    this.line_a_pos = gl.getAttribLocation(this.lineProg, 'a_pos');
    this.line_a_color = gl.getAttribLocation(this.lineProg, 'a_color');

    // Enable blending for transparency
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    gl.enable(gl.DEPTH_TEST);
    gl.depthFunc(gl.LEQUAL);
  }

  resize() {
    if (this._broken) return;
    const dpr = window.devicePixelRatio || 1;
    const rect = this.canvas.parentElement.getBoundingClientRect();
    const w = rect.width;
    const h = rect.height;
    this.canvas.width = w * dpr;
    this.canvas.height = h * dpr;
    this.canvas.style.width = w + 'px';
    this.canvas.style.height = h + 'px';
    this._w = w;
    this._h = h;
    this.gl.viewport(0, 0, w * dpr, h * dpr);
  }

  _drawGrid(mvp) {
    const gl = this.gl;
    const b = parser.bounds;
    const verts = [];
    const step = 10; // 10mm grid
    const isLight = document.documentElement.getAttribute('data-theme') === 'light';
    const gridColor = isLight ? [0.55, 0.56, 0.58, 0.5] : [0.16, 0.18, 0.21, 0.5];

    for (let x = Math.floor(b.minX / step) * step; x <= b.maxX; x += step) {
      verts.push(x, b.minY, 0, ...gridColor, x, b.maxY, 0, ...gridColor);
    }
    for (let y = Math.floor(b.minY / step) * step; y <= b.maxY; y += step) {
      verts.push(b.minX, y, 0, ...gridColor, b.maxX, y, 0, ...gridColor);
    }

    if (verts.length === 0) return;
    const data = new Float32Array(verts);
    const stride = 7 * 4;

    const vbo = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
    gl.bufferData(gl.ARRAY_BUFFER, data, gl.STREAM_DRAW);

    gl.useProgram(this.lineProg);
    gl.uniformMatrix4fv(this.line_u_mvp, false, mvp);
    gl.enableVertexAttribArray(this.line_a_pos);
    gl.vertexAttribPointer(this.line_a_pos, 3, gl.FLOAT, false, stride, 0);
    gl.enableVertexAttribArray(this.line_a_color);
    gl.vertexAttribPointer(this.line_a_color, 4, gl.FLOAT, false, stride, 12);
    gl.drawArrays(gl.LINES, 0, verts.length / 7);
    gl.deleteBuffer(vbo);
  }

  render(layerNum) {
    const gl = this.gl;
    if (this._broken || !this._w || !this._h) return;

    this.currentLayer = layerNum;

    // Clear with theme-appropriate background
    const isDark = document.documentElement.getAttribute('data-theme') !== 'light';
    gl.clearColor(isDark ? 0.067 : 0.878, isDark ? 0.071 : 0.882, isDark ? 0.078 : 0.894, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    const mvp = this._getMVP();

    // Draw bed grid
    this._drawGrid(mvp);

    // Draw layers 0..maxVisibleLayer
    gl.useProgram(this.prog);
    gl.uniformMatrix4fv(this.u_mvp, false, mvp);

    for (let ln = 0; ln <= this.maxVisibleLayer; ln++) {
      const buf = this._buildLayerGeometry(ln);
      if (!buf) continue;

      const isCurrent = (ln === layerNum);

      // Set alpha override: use per-vertex alpha for current layer, dim for others
      const dimAlpha = document.documentElement.getAttribute('data-theme') === 'light' ? 0.45 : 0.25;
      gl.uniform1f(this.u_alphaOverride, isCurrent ? -1.0 : dimAlpha);

      // Draw extrusion ribbons
      if (buf.ribbonVao && buf.ribbonCount > 0) {
        gl.bindVertexArray(buf.ribbonVao);
        gl.drawArrays(gl.TRIANGLES, 0, buf.ribbonCount);
        gl.bindVertexArray(null);
      }

      // Draw travel lines (only for current layer)
      if (isCurrent && buf.travelVao && buf.travelCount > 0) {
        gl.useProgram(this.lineProg);
        gl.uniformMatrix4fv(this.line_u_mvp, false, mvp);
        gl.bindVertexArray(buf.travelVao);
        gl.drawArrays(gl.LINES, 0, buf.travelCount);
        gl.bindVertexArray(null);
        gl.useProgram(this.prog);
        gl.uniformMatrix4fv(this.u_mvp, false, mvp);
      }
    }

    // Draw modification marker planes
    this._drawModMarkers(mvp);
    this._drawHoleHighlights(mvp);
    this._drawMeasurement(mvp);
  }

  _drawModMarkers(mvp) {
    const gl = this.gl;
    const b = parser.bounds;
    const mods = modifier.modifications.filter(m => m.layer !== Infinity && m.layer !== 'end');
    if (mods.length === 0) return;

    const verts = [];
    for (const mod of mods) {
      const layer = parser.getLayerByNumber(mod.layer);
      if (!layer || layer.zHeight == null) continue;
      const z = layer.zHeight + 0.05;

      let color;
      switch (mod.type) {
        case 'pause': color = [0.980, 0.800, 0.082, 0.15]; break;
        case 'filament': color = [0.655, 0.545, 0.980, 0.15]; break;
        case 'zoffset': color = [0.984, 0.573, 0.235, 0.15]; break;
        case 'custom': color = [0.0, 0.784, 1.0, 0.15]; break;
        case 'recovery': color = [1.0, 0.2, 0.2, 0.20]; break;
        default: color = [0.5, 0.5, 0.5, 0.15];
      }

      const margin = 2;
      verts.push(
        b.minX - margin, b.minY - margin, z, ...color,
        b.maxX + margin, b.minY - margin, z, ...color,
        b.maxX + margin, b.maxY + margin, z, ...color,
        b.minX - margin, b.minY - margin, z, ...color,
        b.maxX + margin, b.maxY + margin, z, ...color,
        b.minX - margin, b.maxY + margin, z, ...color,
      );
    }

    if (verts.length === 0) return;
    const data = new Float32Array(verts);
    const stride = 7 * 4;

    gl.useProgram(this.lineProg);
    gl.uniformMatrix4fv(this.line_u_mvp, false, mvp);

    const vbo = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
    gl.bufferData(gl.ARRAY_BUFFER, data, gl.STREAM_DRAW);
    gl.enableVertexAttribArray(this.line_a_pos);
    gl.vertexAttribPointer(this.line_a_pos, 3, gl.FLOAT, false, stride, 0);
    gl.enableVertexAttribArray(this.line_a_color);
    gl.vertexAttribPointer(this.line_a_color, 4, gl.FLOAT, false, stride, 12);
    gl.drawArrays(gl.TRIANGLES, 0, verts.length / 7);
    gl.deleteBuffer(vbo);
  }

  _drawHoleHighlights(mvp) {
    if (!holeDetector || holeDetector.selectedHoles.length === 0) return;
    const gl = this.gl;
    const selected = getSelectedHoleObjects();
    if (selected.length === 0) return;

    // Draw highlight at the currently viewed layer's Z height
    const currentLayerData = parser.getLayerByNumber(this.currentLayer);
    if (!currentLayerData || currentLayerData.zHeight == null) return;
    const z = currentLayerData.zHeight + 0.2;

    const verts = [];
    const fillColor = [0.0, 1.0, 0.4, 0.30];
    const ringColor = [0.0, 1.0, 0.4, 0.70];
    const segments = 36;

    for (const hole of selected) {
      const cx = hole.centroid.x;
      const cy = hole.centroid.y;
      const r = hole.diameterMm / 2;

      // Filled translucent circle
      for (let i = 0; i < segments; i++) {
        const a1 = (i / segments) * Math.PI * 2;
        const a2 = ((i + 1) / segments) * Math.PI * 2;
        verts.push(
          cx, cy, z, ...fillColor,
          cx + r * Math.cos(a1), cy + r * Math.sin(a1), z, ...fillColor,
          cx + r * Math.cos(a2), cy + r * Math.sin(a2), z, ...fillColor,
        );
      }

      // Bright ring outline (annulus)
      const ringW = 0.3;
      const rOuter = r + ringW;
      const rInner = r;
      for (let i = 0; i < segments; i++) {
        const a1 = (i / segments) * Math.PI * 2;
        const a2 = ((i + 1) / segments) * Math.PI * 2;
        const ox1 = cx + rOuter * Math.cos(a1), oy1 = cy + rOuter * Math.sin(a1);
        const ox2 = cx + rOuter * Math.cos(a2), oy2 = cy + rOuter * Math.sin(a2);
        const ix1 = cx + rInner * Math.cos(a1), iy1 = cy + rInner * Math.sin(a1);
        const ix2 = cx + rInner * Math.cos(a2), iy2 = cy + rInner * Math.sin(a2);
        verts.push(
          ox1, oy1, z, ...ringColor, ox2, oy2, z, ...ringColor, ix1, iy1, z, ...ringColor,
          ox2, oy2, z, ...ringColor, ix2, iy2, z, ...ringColor, ix1, iy1, z, ...ringColor,
        );
      }
    }

    if (verts.length === 0) return;
    const data = new Float32Array(verts);
    const stride = 7 * 4;

    gl.useProgram(this.lineProg);
    gl.uniformMatrix4fv(this.line_u_mvp, false, mvp);

    const vbo = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
    gl.bufferData(gl.ARRAY_BUFFER, data, gl.STREAM_DRAW);
    gl.enableVertexAttribArray(this.line_a_pos);
    gl.vertexAttribPointer(this.line_a_pos, 3, gl.FLOAT, false, stride, 0);
    gl.enableVertexAttribArray(this.line_a_color);
    gl.vertexAttribPointer(this.line_a_color, 4, gl.FLOAT, false, stride, 12);
    gl.drawArrays(gl.TRIANGLES, 0, verts.length / 7);
    gl.deleteBuffer(vbo);
  }

  _invertMatrix(m) {
    const inv = new Float32Array(16);
    inv[0] = m[5]*m[10]*m[15] - m[5]*m[11]*m[14] - m[9]*m[6]*m[15] + m[9]*m[7]*m[14] + m[13]*m[6]*m[11] - m[13]*m[7]*m[10];
    inv[4] = -m[4]*m[10]*m[15] + m[4]*m[11]*m[14] + m[8]*m[6]*m[15] - m[8]*m[7]*m[14] - m[12]*m[6]*m[11] + m[12]*m[7]*m[10];
    inv[8] = m[4]*m[9]*m[15] - m[4]*m[11]*m[13] - m[8]*m[5]*m[15] + m[8]*m[7]*m[13] + m[12]*m[5]*m[11] - m[12]*m[7]*m[9];
    inv[12] = -m[4]*m[9]*m[14] + m[4]*m[10]*m[13] + m[8]*m[5]*m[14] - m[8]*m[6]*m[13] - m[12]*m[5]*m[10] + m[12]*m[6]*m[9];
    inv[1] = -m[1]*m[10]*m[15] + m[1]*m[11]*m[14] + m[9]*m[2]*m[15] - m[9]*m[3]*m[14] - m[13]*m[2]*m[11] + m[13]*m[3]*m[10];
    inv[5] = m[0]*m[10]*m[15] - m[0]*m[11]*m[14] - m[8]*m[2]*m[15] + m[8]*m[3]*m[14] + m[12]*m[2]*m[11] - m[12]*m[3]*m[10];
    inv[9] = -m[0]*m[9]*m[15] + m[0]*m[11]*m[13] + m[8]*m[1]*m[15] - m[8]*m[3]*m[13] - m[12]*m[1]*m[11] + m[12]*m[3]*m[9];
    inv[13] = m[0]*m[9]*m[14] - m[0]*m[10]*m[13] - m[8]*m[1]*m[14] + m[8]*m[2]*m[13] + m[12]*m[1]*m[10] - m[12]*m[2]*m[9];
    inv[2] = m[1]*m[6]*m[15] - m[1]*m[7]*m[14] - m[5]*m[2]*m[15] + m[5]*m[3]*m[14] + m[13]*m[2]*m[7] - m[13]*m[3]*m[6];
    inv[6] = -m[0]*m[6]*m[15] + m[0]*m[7]*m[14] + m[4]*m[2]*m[15] - m[4]*m[3]*m[14] - m[12]*m[2]*m[7] + m[12]*m[3]*m[6];
    inv[10] = m[0]*m[5]*m[15] - m[0]*m[7]*m[13] - m[4]*m[1]*m[15] + m[4]*m[3]*m[13] + m[12]*m[1]*m[7] - m[12]*m[3]*m[5];
    inv[14] = -m[0]*m[5]*m[14] + m[0]*m[6]*m[13] + m[4]*m[1]*m[14] - m[4]*m[2]*m[13] - m[12]*m[1]*m[6] + m[12]*m[2]*m[5];
    inv[3] = -m[1]*m[6]*m[11] + m[1]*m[7]*m[10] + m[5]*m[2]*m[11] - m[5]*m[3]*m[10] - m[9]*m[2]*m[7] + m[9]*m[3]*m[6];
    inv[7] = m[0]*m[6]*m[11] - m[0]*m[7]*m[10] - m[4]*m[2]*m[11] + m[4]*m[3]*m[10] + m[8]*m[2]*m[7] - m[8]*m[3]*m[6];
    inv[11] = -m[0]*m[5]*m[11] + m[0]*m[7]*m[9] + m[4]*m[1]*m[11] - m[4]*m[3]*m[9] - m[8]*m[1]*m[7] + m[8]*m[3]*m[5];
    inv[15] = m[0]*m[5]*m[10] - m[0]*m[6]*m[9] - m[4]*m[1]*m[10] + m[4]*m[2]*m[9] + m[8]*m[1]*m[6] - m[8]*m[2]*m[5];
    let det = m[0]*inv[0] + m[1]*inv[4] + m[2]*inv[8] + m[3]*inv[12];
    if (Math.abs(det) < 1e-10) return null;
    det = 1.0 / det;
    for (let i = 0; i < 16; i++) inv[i] *= det;
    return inv;
  }

  _transformPoint(mat, p) {
    const w = mat[3] * p[0] + mat[7] * p[1] + mat[11] * p[2] + mat[15];
    return [
      (mat[0] * p[0] + mat[4] * p[1] + mat[8] * p[2] + mat[12]) / w,
      (mat[1] * p[0] + mat[5] * p[1] + mat[9] * p[2] + mat[13]) / w,
      (mat[2] * p[0] + mat[6] * p[1] + mat[10] * p[2] + mat[14]) / w,
    ];
  }

  screenToLayerPoint(screenX, screenY, layerZ) {
    const invMvp = this._invertMatrix(this._getMVP());
    if (!invMvp) return null;
    const ndcX = (screenX / this._w) * 2 - 1;
    const ndcY = 1 - (screenY / this._h) * 2;
    const near = this._transformPoint(invMvp, [ndcX, ndcY, -1]);
    const far = this._transformPoint(invMvp, [ndcX, ndcY, 1]);
    const dz = far[2] - near[2];
    if (Math.abs(dz) < 0.0001) return null;
    const t = (layerZ - near[2]) / dz;
    return { x: near[0] + t * (far[0] - near[0]), y: near[1] + t * (far[1] - near[1]), z: layerZ };
  }

  _drawMeasurement(mvp) {
    if (!measureMode || measurePoints.length === 0) return;
    const gl = this.gl;
    const verts = [];
    const color = [1.0, 1.0, 1.0, 1.0];

    for (const pt of measurePoints) {
      const s = 0.5;
      verts.push(pt.x - s, pt.y, pt.z, ...color, pt.x + s, pt.y, pt.z, ...color);
      verts.push(pt.x, pt.y - s, pt.z, ...color, pt.x, pt.y + s, pt.z, ...color);
    }

    if (measurePoints.length === 2) {
      const [a, b] = measurePoints;
      verts.push(a.x, a.y, a.z, ...color, b.x, b.y, b.z, ...color);
    }

    if (verts.length === 0) return;
    const data = new Float32Array(verts);
    const stride = 7 * 4;
    gl.useProgram(this.lineProg);
    gl.uniformMatrix4fv(this.line_u_mvp, false, mvp);
    const vbo = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
    gl.bufferData(gl.ARRAY_BUFFER, data, gl.STREAM_DRAW);
    gl.enableVertexAttribArray(this.line_a_pos);
    gl.vertexAttribPointer(this.line_a_pos, 3, gl.FLOAT, false, stride, 0);
    gl.enableVertexAttribArray(this.line_a_color);
    gl.vertexAttribPointer(this.line_a_color, 4, gl.FLOAT, false, stride, 12);
    gl.drawArrays(gl.LINES, 0, verts.length / 7);
    gl.deleteBuffer(vbo);
  }

  fitBounds() {
    this.cam.rotX = 0.6;
    this.cam.rotZ = 0.4;
    this.cam.panX = 0;
    this.cam.panY = 0;
    this.cam.zoom = 1.0;
  }

  _setupInteraction() {
    const c = this.canvas;

    c.addEventListener('contextmenu', e => e.preventDefault());

    c.addEventListener('mousedown', e => {
      this._dragging = true;
      this._dragButton = e.button;
      this._lastMouse = { x: e.clientX, y: e.clientY };
      this._mouseMoved = false;
      e.preventDefault();
    });

    window.addEventListener('mousemove', e => {
      if (!this._dragging) return;
      const dx = e.clientX - this._lastMouse.x;
      const dy = e.clientY - this._lastMouse.y;
      if (Math.abs(dx) > 2 || Math.abs(dy) > 2) this._mouseMoved = true;

      if (this._dragButton === 0) {
        // Left-drag: orbit
        this.cam.rotZ += dx * 0.005;
        this.cam.rotX = Math.max(0.01, Math.min(Math.PI / 2 - 0.01, this.cam.rotX - dy * 0.005));
      } else if (this._dragButton === 1 || this._dragButton === 2) {
        // Middle or right drag: pan
        const panScale = 0.5 / this.cam.zoom;
        this.cam.panX -= dx * panScale * Math.cos(this.cam.rotZ) + dy * panScale * Math.sin(this.cam.rotZ);
        this.cam.panY += dx * panScale * Math.sin(this.cam.rotZ) - dy * panScale * Math.cos(this.cam.rotZ);
      }

      this._lastMouse = { x: e.clientX, y: e.clientY };
      this.render(this.currentLayer);
    });

    window.addEventListener('mouseup', () => { this._dragging = false; });

    // Scroll to zoom
    c.addEventListener('wheel', e => {
      e.preventDefault();
      const factor = e.deltaY < 0 ? 1.1 : 1 / 1.1;
      this.cam.zoom *= factor;
      this.cam.zoom = Math.max(0.1, Math.min(50, this.cam.zoom));
      this.render(this.currentLayer);
    }, { passive: false });

    // Touch support
    let lastTouchDist = 0;
    let lastTouchMid = null;

    c.addEventListener('touchstart', e => {
      if (e.touches.length === 1) {
        this._dragging = true;
        this._dragButton = 0;
        this._lastMouse = { x: e.touches[0].clientX, y: e.touches[0].clientY };
      } else if (e.touches.length === 2) {
        this._dragging = false;
        lastTouchDist = Math.hypot(
          e.touches[0].clientX - e.touches[1].clientX,
          e.touches[0].clientY - e.touches[1].clientY
        );
        lastTouchMid = {
          x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
          y: (e.touches[0].clientY + e.touches[1].clientY) / 2,
        };
      }
    }, { passive: true });

    c.addEventListener('touchmove', e => {
      e.preventDefault();
      if (e.touches.length === 1 && this._dragging) {
        const dx = e.touches[0].clientX - this._lastMouse.x;
        const dy = e.touches[0].clientY - this._lastMouse.y;
        this.cam.rotZ += dx * 0.005;
        this.cam.rotX = Math.max(0.01, Math.min(Math.PI / 2 - 0.01, this.cam.rotX - dy * 0.005));
        this._lastMouse = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        this.render(this.currentLayer);
      } else if (e.touches.length === 2) {
        // Pinch zoom
        const dist = Math.hypot(
          e.touches[0].clientX - e.touches[1].clientX,
          e.touches[0].clientY - e.touches[1].clientY
        );
        if (lastTouchDist) {
          this.cam.zoom *= dist / lastTouchDist;
          this.cam.zoom = Math.max(0.1, Math.min(50, this.cam.zoom));
        }
        // Two-finger pan
        const mid = {
          x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
          y: (e.touches[0].clientY + e.touches[1].clientY) / 2,
        };
        if (lastTouchMid) {
          const dx = mid.x - lastTouchMid.x;
          const dy = mid.y - lastTouchMid.y;
          const panScale = 0.5 / this.cam.zoom;
          this.cam.panX -= dx * panScale * Math.cos(this.cam.rotZ) + dy * panScale * Math.sin(this.cam.rotZ);
          this.cam.panY += dx * panScale * Math.sin(this.cam.rotZ) - dy * panScale * Math.cos(this.cam.rotZ);
        }
        lastTouchDist = dist;
        lastTouchMid = mid;
        this.render(this.currentLayer);
      }
    }, { passive: false });

    c.addEventListener('touchend', () => {
      this._dragging = false;
      lastTouchDist = 0;
      lastTouchMid = null;
    });


    // Measurement click handler
    c.addEventListener('click', e => {
      if (!measureMode || this._mouseMoved) return;
      const rect = c.getBoundingClientRect();
      const sx = e.clientX - rect.left;
      const sy = e.clientY - rect.top;
      const layer = parser.getLayerByNumber(this.currentLayer);
      const z = layer?.zHeight || 0;
      const pt = this.screenToLayerPoint(sx, sy, z);
      if (pt) {
        measurePoints.push(pt);
        if (measurePoints.length > 2) measurePoints = [measurePoints[measurePoints.length - 1]];
        this.render(this.currentLayer);
        if (measurePoints.length === 2) {
          const [a, b] = measurePoints;
          const dist = Math.hypot(a.x - b.x, a.y - b.y, a.z - b.z);
          showToast('Distance: ' + dist.toFixed(2) + ' mm', 'success', 6000);
        }
      }
    });

    // Resize observer
    new ResizeObserver(() => {
      if (currentView === 'visual') { this.resize(); this.render(this.currentLayer); }
    }).observe(c.parentElement);
  }
}

const viewer = new GcodeViewer3D('viewerCanvas');

// ===== HOLE DETECTION UI =====
function toggleHoleMode() {
  holeDetectMode = !holeDetectMode;
  const btn = document.getElementById('holeDetectToggle');
  const canvas = document.getElementById('viewerCanvas');
  btn.classList.toggle('active', holeDetectMode);
  canvas.classList.toggle('hole-mode', holeDetectMode);

  if (holeDetectMode) {
    switchTab('inserts');
    if (currentView !== 'visual') setView('visual');
  }
}

function detectHolesOnLayer() {
  if (selectedLayer === null) { showToast('Please select a layer first.', 'warning'); return; }
  if (currentView !== 'visual') setView('visual');

  const minDia = parseFloat(document.getElementById('holeMinDia').value) || 4;
  const ignoreInfill = document.getElementById('holeIgnoreInfill').checked;

  holeDetector.scannedHoles = []; // clear any full-scan results
  const holes = holeDetector.detectHoles(selectedLayer, minDia, ignoreInfill);

  // Analyze depth for each hole
  for (const hole of holes) {
    holeDetector.analyzeHoleDepth(hole, selectedLayer);
  }

  holeDetector.selectedHoles = [];
  renderHoleList();
  viewer.render(selectedLayer);

  if (!holeDetectMode) toggleHoleMode();
}

async function scanAllHoles() {
  if (!parser || !parser.layers || parser.layers.length === 0) {
    showToast('Please load a G-code file first.', 'warning');
    return;
  }
  if (currentView !== 'visual') setView('visual');

  const minDia = parseFloat(document.getElementById('holeMinDia').value) || 4;
  const ignoreInfill = document.getElementById('holeIgnoreInfill').checked;

  const btn = document.getElementById('scanAllBtn');
  const origText = btn.textContent;
  btn.disabled = true;
  btn.textContent = 'Scanning...';

  const totalLayers = parser.layers.length;
  const holes = await holeDetector.scanAllLayers(minDia, ignoreInfill, (done, total) => {
    btn.textContent = `Scanning ${Math.round(done / total * 100)}%`;
  });

  btn.disabled = false;
  btn.textContent = origText;

  renderHoleList();
  if (viewer) viewer.render(viewer.currentLayer);

  if (!holeDetectMode) toggleHoleMode();

  if (holes.length === 0) {
    showToast('No holes detected in the print.', 'warning');
  } else {
    showToast(`Found ${holes.length} hole(s) across all layers.`, 'success');
  }
}

function renderHoleList() {
  const wrap = document.getElementById('holeListWrap');
  const holes = holeDetector.scannedHoles.length > 0
    ? holeDetector.scannedHoles
    : (selectedLayer !== null ? (holeDetector.holes.get(selectedLayer) || []) : []);

  if (holes.length === 0) {
    wrap.innerHTML = '<div class="no-holes" id="noHoles">Click "Detect (Layer)" or "Scan All Layers"</div>';
    return;
  }

  const isScanned = holeDetector.scannedHoles.length > 0;
  let html = '';
  holes.forEach((hole, i) => {
    const isSelected = holeDetector.selectedHoles.includes(hole.id);
    const depthStr = hole.depthMm != null ? `${hole.depthMm.toFixed(1)}mm deep` :
                     (hole.floorLayer === -1 ? 'through-hole' : 'depth unknown');

    // Shape and dimension info
    const shapeIcon = { circle: '\u25cb', hexagon: '\u2b21', square: '\u25a1', rectangle: '\u25ad' }[hole.shape] || '';
    const shapeName = hole.shape || 'unknown';
    let dimStr;
    if (hole.shape === 'circle') {
      dimStr = `${hole.diameterMm.toFixed(1)}mm dia`;
    } else if (hole.widthMm && hole.heightMm) {
      dimStr = `${hole.widthMm.toFixed(1)} &times; ${hole.heightMm.toFixed(1)}mm`;
    } else {
      dimStr = `${hole.diameterMm.toFixed(1)}mm dia`;
    }

    // Clickable layer links
    const floorLink = hole.floorLayer >= 0
      ? `<a href="#" onclick="event.stopPropagation();jumpToLayer(${hole.floorLayer})" style="color:var(--accent);text-decoration:underline">${hole.floorLayer}</a>`
      : 'none';
    const topLayerNum = hole.topLayer ?? hole.layerNum;
    const topLink = isScanned
      ? ` &middot; top <a href="#" onclick="event.stopPropagation();jumpToLayer(${topLayerNum})" style="color:var(--accent);text-decoration:underline">${topLayerNum}</a>`
      : '';

    html += `<div class="hole-item${isSelected ? ' selected' : ''}" onclick="toggleHoleSelection('${hole.id}', event)">
      <span class="hole-id">#${i + 1}</span>
      <div class="hole-info">
        ${shapeIcon} ${shapeName} &middot; ${dimStr} &middot; ${hole.areaMm2.toFixed(1)}mm&sup2;
        <span>${depthStr} &middot; floor ${floorLink}${topLink}</span>
      </div>
    </div>`;
  });
  wrap.innerHTML = html;
}

function toggleHoleSelection(holeId, event) {
  const ctrlOrCmd = event && (event.ctrlKey || event.metaKey);
  if (ctrlOrCmd) {
    const idx = holeDetector.selectedHoles.indexOf(holeId);
    if (idx >= 0) holeDetector.selectedHoles.splice(idx, 1);
    else holeDetector.selectedHoles.push(holeId);
  } else {
    if (holeDetector.selectedHoles.length === 1 && holeDetector.selectedHoles[0] === holeId) {
      holeDetector.selectedHoles = [];
    } else {
      holeDetector.selectedHoles = [holeId];
    }
  }

  renderHoleList();
  updateComputedPauseInfo();
  if (currentView === 'visual') viewer.render(viewer.currentLayer);
}

function updateComputedPauseInfo() {
  const container = document.getElementById('computedPauseInfo');
  const selected = getSelectedHoleObjects();
  if (selected.length === 0) { container.innerHTML = ''; return; }

  const heightVal = parseFloat(document.getElementById('insertHeight').value) || 3;
  const heightUnit = document.getElementById('insertHeightUnit').value;

  let html = '';
  for (const hole of selected) {
    let insertMm = heightVal;
    if (heightUnit === 'layers' && hole.floorLayer >= 0) {
      const floorData = parser.getLayerByNumber(hole.floorLayer);
      const startData = parser.getLayerByNumber(hole.layerNum);
      if (floorData && startData && floorData.zHeight != null && startData.zHeight != null) {
        const layerH = (startData.zHeight - floorData.zHeight) / Math.max(1, hole.layerNum - hole.floorLayer);
        insertMm = heightVal * layerH;
      }
    }

    const pauseLayer = insertManager.calculatePauseLayer(hole, insertMm);
    if (pauseLayer != null) {
      const pauseData = parser.getLayerByNumber(pauseLayer);
      const zStr = pauseData?.zHeight != null ? ` (Z${pauseData.zHeight.toFixed(2)}mm)` : '';
      html += `<div class="computed-layer">Hole #${holeDetector.holes.get(hole.layerNum)?.indexOf(hole) + 1}: pause at layer ${pauseLayer}${zStr}</div>`;
    } else if (hole.floorLayer < 0) {
      html += `<div class="warning-msg">Hole is a through-hole — cannot compute pause layer</div>`;
    } else {
      html += `<div class="warning-msg">Insert may be taller than remaining print</div>`;
    }
  }
  container.innerHTML = html;
}

function getSelectedHoleObjects() {
  const results = [];
  for (const [layerNum, holes] of holeDetector.holes) {
    for (const hole of holes) {
      if (holeDetector.selectedHoles.includes(hole.id)) results.push(hole);
    }
  }
  return results;
}

function addInsertsForSelection() {
  const selected = getSelectedHoleObjects();
  if (selected.length === 0) { showToast('Please select at least one hole first.', 'warning'); return; }

  const heightVal = parseFloat(document.getElementById('insertHeight').value);
  if (!heightVal || heightVal <= 0) { showToast('Please enter a valid insert height.', 'error'); return; }

  const heightUnit = document.getElementById('insertHeightUnit').value;
  const diameterMm = parseFloat(document.getElementById('insertDiameter').value) || 6;
  const label = document.getElementById('insertLabel').value.trim();
  const pauseType = document.querySelector('input[name="insertPauseType"]:checked').value;
  const moveHead = document.getElementById('insertMoveHead').checked;

  let addedCount = 0;
  for (const hole of selected) {
    let insertMm = heightVal;
    if (heightUnit === 'layers' && hole.floorLayer >= 0) {
      const floorData = parser.getLayerByNumber(hole.floorLayer);
      const startData = parser.getLayerByNumber(hole.layerNum);
      if (floorData && startData && floorData.zHeight != null && startData.zHeight != null) {
        const layerH = (startData.zHeight - floorData.zHeight) / Math.max(1, hole.layerNum - hole.floorLayer);
        insertMm = heightVal * layerH;
      }
    }

    const result = insertManager.createModification(hole, insertMm, diameterMm, label, pauseType, moveHead);
    if (result) addedCount++;
  }

  if (addedCount === 0) { showToast('Could not compute pause layers for the selected holes. They may be through-holes.', 'error'); return; }

  holeDetector.selectedHoles = [];
  refreshAfterMod();
  renderHoleList();
  updateComputedPauseInfo();
  showToast(addedCount + ' insert pause(s) added successfully', 'success');
}

// Update computed info when insert height changes
document.addEventListener('DOMContentLoaded', () => {
  const heightInput = document.getElementById('insertHeight');
  const unitSelect = document.getElementById('insertHeightUnit');
  if (heightInput) heightInput.addEventListener('input', updateComputedPauseInfo);
  if (unitSelect) unitSelect.addEventListener('change', updateComputedPauseInfo);
});

// ===== EXPORT =====
function exportGcode() {
  if (parser.lines.length === 0) return;

  const modifiedLines = modifier.applyAll(parser.lines, parser);
  const text = modifiedLines.join('\n');
  const blob = new Blob([text], { type: 'text/plain' });
  const url = URL.createObjectURL(blob);

  const baseName = parser.fileName.replace(/\.gcode$/i, '');
  const recoveryMod = modifier.modifications.find(m => m.type === 'recovery');
  const suffix = recoveryMod ? `_recovery_L${recoveryMod.resumeLayer}` : '_modified';
  const a = document.createElement('a');
  a.href = url;
  a.download = baseName + suffix + '.gcode';
  a.click();
  URL.revokeObjectURL(url);
}

// ===== UNDO/REDO =====
function performUndo() {
  const state = undoStack.undo();
  if (state) {
    modifier.modifications = state;
    renderModsList();
    renderLayerList();
    updateSlider();
    if (selectedLayer !== null) {
      renderPreview(selectedLayer);
      if (currentView === 'visual') {
        viewer.maxVisibleLayer = selectedLayer;
        viewer.render(selectedLayer);
        updateViewerOverlay(selectedLayer);
      }
    }
  }
}

function performRedo() {
  const state = undoStack.redo();
  if (state) {
    modifier.modifications = state;
    renderModsList();
    renderLayerList();
    updateSlider();
    if (selectedLayer !== null) {
      renderPreview(selectedLayer);
      if (currentView === 'visual') {
        viewer.maxVisibleLayer = selectedLayer;
        viewer.render(selectedLayer);
        updateViewerOverlay(selectedLayer);
      }
    }
  }
}

function toggleShortcutsOverlay() {
  document.getElementById('shortcutsOverlay').classList.toggle('active');
}

// ===== RIGHT PANEL RESIZE =====
(function() {
  const handle = document.getElementById('panelRightResize');
  const panel = document.getElementById('panelRight');
  let dragging = false, startX, startW;
  handle.addEventListener('mousedown', e => {
    e.preventDefault();
    dragging = true;
    startX = e.clientX;
    startW = panel.offsetWidth;
    handle.classList.add('dragging');
    document.body.style.cursor = 'col-resize';
    document.body.style.userSelect = 'none';
  });
  window.addEventListener('mousemove', e => {
    if (!dragging) return;
    const newW = startW - (e.clientX - startX);
    panel.style.width = Math.max(280, Math.min(window.innerWidth * 0.6, newW)) + 'px';
  });
  window.addEventListener('mouseup', () => {
    if (!dragging) return;
    dragging = false;
    handle.classList.remove('dragging');
    document.body.style.cursor = '';
    document.body.style.userSelect = '';
  });
})();

window.addEventListener('keydown', e => {
  const isInput = e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT';

  // Undo/redo (works even in inputs)
  if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) { e.preventDefault(); performUndo(); return; }
  if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) { e.preventDefault(); performRedo(); return; }

  // Ctrl shortcuts (work everywhere)
  if ((e.ctrlKey || e.metaKey) && e.key === 'e') { e.preventDefault(); exportGcode(); return; }
  if ((e.ctrlKey || e.metaKey) && e.key === 'o') { e.preventDefault(); document.getElementById('fileInput').click(); return; }

  if (isInput) return;

  // Tab switching: 1-8
  const tabKeys = { '1': 'pause', '2': 'filament', '3': 'eject', '4': 'zoffset', '5': 'custom', '6': 'inserts', '7': 'reference', '8': 'recovery' };
  if (tabKeys[e.key]) { switchTab(tabKeys[e.key]); return; }

  // Layer navigation
  if (e.key === '[' || e.key === 'ArrowLeft' || e.key === 'ArrowDown') {
    e.preventDefault();
    const slider = document.getElementById('layerSlider');
    slider.value = Math.max(0, +slider.value - 1);
    onSliderChange(+slider.value);
    return;
  }
  if (e.key === ']' || e.key === 'ArrowRight' || e.key === 'ArrowUp') {
    e.preventDefault();
    const slider = document.getElementById('layerSlider');
    slider.value = Math.min(+slider.max, +slider.value + 1);
    onSliderChange(+slider.value);
    return;
  }

  // View toggle
  if (e.key === ' ') { e.preventDefault(); setView(currentView === 'code' ? 'visual' : 'code'); return; }

  // Reset camera
  if (e.key === 'f' && currentView === 'visual') { viewer.fitBounds(); viewer.render(viewer.currentLayer); return; }

  // Help overlay
  if (e.key === '?') { toggleShortcutsOverlay(); return; }
});

// ===== THEME SUPPORT =====
function getPreferredTheme() {
  const stored = localStorage.getItem('gcode_theme');
  if (stored) return stored;
  return window.matchMedia('(prefers-color-scheme: light)').matches ? 'light' : 'dark';
}

function applyTheme(theme) {
  document.documentElement.setAttribute('data-theme', theme);
  document.getElementById('themeIcon').textContent = theme === 'light' ? '\u2600' : '\u263D';
  localStorage.setItem('gcode_theme', theme);
}

function toggleTheme() {
  const current = document.documentElement.getAttribute('data-theme') || 'dark';
  applyTheme(current === 'dark' ? 'light' : 'dark');
  if (currentView === 'visual') viewer.render(viewer.currentLayer);
}

applyTheme(getPreferredTheme());
</script>
</body>
</html>
