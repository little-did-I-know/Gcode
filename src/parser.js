// ===== G-CODE PARSER =====
export class GcodeParser {
  constructor() {
    this.lines = [];
    this.layers = [];
    this.headerEnd = 0;
    this.fileName = '';
    this.warnings = [];
    this.skippedLines = 0;
  }

  _detectSlicer(lines) {
    const scanLines = Math.min(50, lines.length);
    for (let i = 0; i < scanLines; i++) {
      const line = lines[i];
      if (line.includes('Generated with Cura_SteamEngine')) return 'cura';
      if (line.includes('generated by PrusaSlicer')) return 'prusaslicer';
      if (line.includes('generated by SuperSlicer')) return 'superslicer';
      if (line.includes('generated by OrcaSlicer')) return 'orcaslicer';
      if (line.includes('G-Code generated by Simplify3D')) return 'simplify3d';
      if (line.includes('Sliced by ideaMaker')) return 'ideamaker';
      if (line.includes('BambuStudio') || line.includes('Bambu Studio')) return 'bambu';
    }
    return 'unknown';
  }

  async parseAsync(text, fileName, onProgress) {
    this.fileName = fileName;
    this.lines = text.split(/\r?\n/);
    this.slicerType = this._detectSlicer(this.lines);
    this.layers = [];
    this.layerMoves = {};
    this.bounds = { minX: Infinity, maxX: -Infinity, minY: Infinity, maxY: -Infinity };
    this.headerEnd = 0;
    this.warnings = [];
    this.skippedLines = 0;

    let currentLayer = null;
    let foundFirstLayer = false;
    // State machine for tracking head position
    let curX = 0, curY = 0, curZ = 0, curE = 0;
    let relativeE = false; // M83 = relative, M82 = absolute
    let currentType = 'DEFAULT';
    // Bambu Studio uses "; CHANGE_LAYER" as a marker, with layer number on a nearby line
    let pendingChangeLayer = false;
    let pendingZHeight = null;

    const CHUNK = 50000;
    const total = this.lines.length;

    for (let start = 0; start < total; start += CHUNK) {
      const end = Math.min(start + CHUNK, total);

    for (let i = start; i < end; i++) {
      const line = this.lines[i].trim();

      // Detect header end
      if (!foundFirstLayer && !this.headerEnd) {
        const lm = line.match(/^;LAYER:(\d+)/i) || line.match(/^; CHANGE_LAYER/) || line.match(/^; layer \d+, Z = /i) || line === ';LAYER_CHANGE';
        if (lm) { this.headerEnd = i; foundFirstLayer = true; }
        else if (line && !line.startsWith(';') && (line.startsWith('G') || line.startsWith('M') || line.startsWith('T'))) {
          if (!this.headerEnd) this.headerEnd = i;
        }
      }

      // Parse layer markers — standard format: ;LAYER:N
      const layerMatch = line.match(/^;LAYER:(\d+)/i);
      if (layerMatch) {
        foundFirstLayer = true;
        if (currentLayer) {
          currentLayer.endLine = i - 1;
          currentLayer.lineCount = currentLayer.endLine - currentLayer.startLine + 1;
        }
        currentLayer = {
          number: parseInt(layerMatch[1]),
          startLine: i, endLine: null, zHeight: null,
          sectionTypes: [], lineCount: 0
        };
        this.layers.push(currentLayer);
        this.layerMoves[currentLayer.number] = [];
        currentType = 'DEFAULT';
      }

      // Parse layer markers — Bambu Studio format: ; CHANGE_LAYER + ; Z_HEIGHT + ; layer num/total_layer_count
      if (line === '; CHANGE_LAYER') {
        pendingChangeLayer = true;
        pendingZHeight = null;
        // Mark the start line as this CHANGE_LAYER comment
        foundFirstLayer = true;
        if (currentLayer) {
          currentLayer.endLine = i - 1;
          currentLayer.lineCount = currentLayer.endLine - currentLayer.startLine + 1;
        }
        // Create a temporary layer — number will be updated when we find the layer num comment
        currentLayer = {
          number: this.layers.length, // temporary, updated below
          startLine: i, endLine: null, zHeight: null,
          sectionTypes: [], lineCount: 0,
          _pending: true
        };
        currentType = 'DEFAULT';
      }

      // Bambu: ; Z_HEIGHT: 0.2
      if (pendingChangeLayer) {
        const zHMatch = line.match(/^; Z_HEIGHT:\s*([\d.]+)/);
        if (zHMatch) {
          pendingZHeight = parseFloat(zHMatch[1]);
          if (currentLayer) currentLayer.zHeight = pendingZHeight;
        }

        // Bambu: ; layer num/total_layer_count: 1/525
        const bambuLayerMatch = line.match(/^; layer num\/total_layer_count:\s*(\d+)\/(\d+)/);
        if (bambuLayerMatch) {
          const layerNum = parseInt(bambuLayerMatch[1]) - 1; // Bambu uses 1-based, convert to 0-based
          if (currentLayer && currentLayer._pending) {
            currentLayer.number = layerNum;
            delete currentLayer._pending;
            this.layers.push(currentLayer);
            this.layerMoves[currentLayer.number] = [];
          }
          pendingChangeLayer = false;
        }
      }

      // Simplify3D: "; layer N, Z = X.XX"
      const s3dLayerMatch = line.match(/^; layer (\d+), Z = ([\d.]+)/i);
      if (s3dLayerMatch) {
        foundFirstLayer = true;
        if (currentLayer) {
          currentLayer.endLine = i - 1;
          currentLayer.lineCount = currentLayer.endLine - currentLayer.startLine + 1;
        }
        currentLayer = {
          number: parseInt(s3dLayerMatch[1]),
          startLine: i, endLine: null,
          zHeight: parseFloat(s3dLayerMatch[2]),
          sectionTypes: [], lineCount: 0
        };
        this.layers.push(currentLayer);
        this.layerMoves[currentLayer.number] = [];
        currentType = 'DEFAULT';
      }

      // PrusaSlicer alternative: ;LAYER_CHANGE + ;Z:X.XX
      if (line === ';LAYER_CHANGE') {
        foundFirstLayer = true;
        if (currentLayer) {
          currentLayer.endLine = i - 1;
          currentLayer.lineCount = currentLayer.endLine - currentLayer.startLine + 1;
        }
        currentLayer = {
          number: this.layers.length,
          startLine: i, endLine: null, zHeight: null,
          sectionTypes: [], lineCount: 0
        };
        this.layers.push(currentLayer);
        this.layerMoves[currentLayer.number] = [];
        currentType = 'DEFAULT';
      }
      if (currentLayer && !currentLayer.zHeight) {
        const zDirectMatch = line.match(/^;Z:([\d.]+)/);
        if (zDirectMatch) currentLayer.zHeight = parseFloat(zDirectMatch[1]);
      }

      // Extract Z-height (fallback from G0/G1 moves)
      if (currentLayer && !currentLayer.zHeight) {
        const zMatch = line.match(/G[01]\s.*Z([\d.]+)/i);
        if (zMatch) currentLayer.zHeight = parseFloat(zMatch[1]);
      }

      // Extract section types — standard: ;TYPE:X  or Bambu: ; FEATURE: X
      if (currentLayer) {
        const typeMatch = line.match(/^;TYPE:(.+)/i) || line.match(/^; FEATURE:\s*(.+)/i);
        if (typeMatch) {
          // Normalize PrusaSlicer/SuperSlicer type names
          const typeNormalize = {
            'External perimeter': 'WALL-OUTER',
            'Perimeter': 'WALL-INNER',
            'Solid infill': 'SOLID',
            'Top solid infill': 'TOP',
            'Bottom solid infill': 'BOTTOM',
            'Bridge infill': 'BRIDGE',
            'Gap fill': 'GAP INFILL',
            'Overhang perimeter': 'OVERHANG',
            'Internal infill': 'FILL',
            'Sparse infill': 'FILL',
            'Skirt': 'SKIRT',
            'Skirt/Brim': 'SKIRT',
            'Support material': 'SUPPORT',
            'Support material interface': 'SUPPORT-INTERFACE',
          };
          const rawType = typeMatch[1].trim();
          currentType = typeNormalize[rawType] || rawType.toUpperCase();
          if (!currentLayer.sectionTypes.includes(currentType)) currentLayer.sectionTypes.push(currentType);
        }

        // Simplify3D: "; outer perimeter", "; inner perimeter", etc.
        if (!typeMatch) {
          const s3dType = line.match(/^; (outer perimeter|inner perimeter|solid layer|infill|support|raft|skirt|gap fill|bridge)/i);
          if (s3dType) {
            const typeMap = {
              'outer perimeter': 'WALL-OUTER',
              'inner perimeter': 'WALL-INNER',
              'solid layer': 'SOLID',
              'infill': 'FILL',
              'support': 'SUPPORT',
              'raft': 'SUPPORT',
              'skirt': 'SKIRT',
              'gap fill': 'GAP INFILL',
              'bridge': 'BRIDGE',
            };
            currentType = typeMap[s3dType[1].toLowerCase()] || s3dType[1].toUpperCase();
            if (!currentLayer.sectionTypes.includes(currentType)) currentLayer.sectionTypes.push(currentType);
          }
        }
      }

      // Track extrusion mode
      if (line === 'M83') relativeE = true;
      if (line === 'M82') relativeE = false;
      if (line.startsWith('G92') && line.includes('E')) { curE = 0; } // Reset E position

      // Parse G0/G1 linear moves for the viewer
      if (currentLayer && this.layerMoves[currentLayer.number] && /^G[01]\s/.test(line)) {
        try {
        const params = {};
        const matches = line.matchAll(/([XYZEF])([-\d.]+)/gi);
        for (const m of matches) params[m[1].toUpperCase()] = parseFloat(m[2]);

        const newX = params.X !== undefined ? params.X : curX;
        const newY = params.Y !== undefined ? params.Y : curY;
        const newZ = params.Z !== undefined ? params.Z : curZ;
        const isG0 = line.startsWith('G0');
        let isExtrude = false;
        if (params.E !== undefined) {
          isExtrude = relativeE ? params.E > 0 : params.E > curE;
          curE = relativeE ? curE + params.E : params.E;
        }

        // Only record XY moves (skip pure Z moves)
        if (newX !== curX || newY !== curY) {
          this.layerMoves[currentLayer.number].push({
            x1: curX, y1: curY, x2: newX, y2: newY,
            type: currentType, extrude: isExtrude && !isG0
          });
          this.bounds.minX = Math.min(this.bounds.minX, curX, newX);
          this.bounds.maxX = Math.max(this.bounds.maxX, curX, newX);
          this.bounds.minY = Math.min(this.bounds.minY, curY, newY);
          this.bounds.maxY = Math.max(this.bounds.maxY, curY, newY);
        }

        curX = newX; curY = newY; curZ = newZ;
        } catch (err) {
          this.skippedLines++;
        }
      }

      // Parse G2/G3 arc moves (Bambu Studio uses arc fitting)
      if (currentLayer && this.layerMoves[currentLayer.number] && /^G[23]\s/.test(line)) {
        try {
        const params = {};
        const matches = line.matchAll(/([XYZEFIJ])([-\d.]+)/gi);
        for (const m of matches) params[m[1].toUpperCase()] = parseFloat(m[2]);

        const newX = params.X !== undefined ? params.X : curX;
        const newY = params.Y !== undefined ? params.Y : curY;
        let isExtrude = false;
        if (params.E !== undefined) {
          isExtrude = relativeE ? params.E > 0 : params.E > curE;
          curE = relativeE ? curE + params.E : params.E;
        }
        const isG2 = line.startsWith('G2'); // clockwise

        // Approximate arc with line segments
        const cx = curX + (params.I || 0);
        const cy = curY + (params.J || 0);
        const r = Math.hypot(params.I || 0, params.J || 0);
        if (r > 0.01) {
          let startAngle = Math.atan2(curY - cy, curX - cx);
          let endAngle = Math.atan2(newY - cy, newX - cx);
          // Adjust sweep direction
          if (isG2) { // CW
            if (endAngle >= startAngle) endAngle -= 2 * Math.PI;
          } else { // CCW
            if (endAngle <= startAngle) endAngle += 2 * Math.PI;
          }
          const segments = Math.max(4, Math.ceil(Math.abs(endAngle - startAngle) / (Math.PI / 12)));
          let prevAX = curX, prevAY = curY;
          for (let s = 1; s <= segments; s++) {
            const t = s / segments;
            const angle = startAngle + (endAngle - startAngle) * t;
            const ax = s === segments ? newX : cx + r * Math.cos(angle);
            const ay = s === segments ? newY : cy + r * Math.sin(angle);
            this.layerMoves[currentLayer.number].push({
              x1: prevAX, y1: prevAY, x2: ax, y2: ay,
              type: currentType, extrude: isExtrude
            });
            this.bounds.minX = Math.min(this.bounds.minX, ax);
            this.bounds.maxX = Math.max(this.bounds.maxX, ax);
            this.bounds.minY = Math.min(this.bounds.minY, ay);
            this.bounds.maxY = Math.max(this.bounds.maxY, ay);
            prevAX = ax; prevAY = ay;
          }
        }

        curX = newX; curY = newY;
        } catch (err) {
          this.skippedLines++;
        }
      }
    }

      if (onProgress) onProgress(Math.min(end / total, 1));
      if (end < total) await new Promise(r => setTimeout(r, 0));
    }

    // Finalize any pending Bambu layer that never got its layer num line
    if (currentLayer && currentLayer._pending) {
      delete currentLayer._pending;
      this.layers.push(currentLayer);
      this.layerMoves[currentLayer.number] = [];
    }

    // Close last layer
    if (currentLayer) {
      currentLayer.endLine = this.lines.length - 1;
      currentLayer.lineCount = currentLayer.endLine - currentLayer.startLine + 1;
    }

    // Sanitize bounds
    if (!isFinite(this.bounds.minX)) this.bounds = { minX: 0, maxX: 256, minY: 0, maxY: 256 };

    return this.layers;
  }

  getLayerByNumber(num) {
    return this.layers.find(l => l.number === num);
  }
}
